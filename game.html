<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>M4NFROID GALACTICA v9 - FULL LOOT INTEGRATION</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap');
:root{
  --hud-h: 60px;
  --controls-h: 22vh;
  --controls-vh: 22;
  --vh: 1vh;
  --accent: #00ff88;
  --accent2: #00d4ff;
  --accent3: #ff00ff;
  --bg: #000;
  --panel: rgba(0,0,0,.65);
  --panel2: rgba(0,255,136,.10);
  --border: rgba(0,255,136,.35);
  --text: #eafff6;
  --muted: rgba(234,255,246,.7);
  --danger: #ff3b3b;
  --gold: #ffd700;
  --neon-pink: #ff006e;
  --neon-blue: #00f5ff;
  --neon-purple: #9d00ff;
  /* RARITY COLORS */
  --rarity-normal: #9CA3AF;
  --rarity-rare: #3B82F6;
  --rarity-epic: #8B5CF6;
  --rarity-legendary: #F59E0B;
  --rarity-mythic: #EC4899;
}

@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap');

*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}

body{
background:var(--bg);
color:var(--text);
font-family: 'Rajdhani', 'Orbitron', ui-monospace, monospace;
overflow:hidden;
touch-action:none;
height:100vh; height:100dvh; height:calc(var(--vh, 1vh) * 100); width:100vw;
}

#gameContainer{
position:absolute;top:0;left:0;right:0;
height:calc((var(--vh, 1vh) * 100) - (var(--vh, 1vh) * var(--controls-vh)));
background:#000;
overflow:hidden;
}

canvas{position:absolute;left:0;top:0;width:100%;height:100%;display:block}
#backgroundCanvas{z-index:0}
#gameCanvas{z-index:1}
#fxCanvas{z-index:2;pointer-events:none}
#overlayCanvas{z-index:3;pointer-events:none}

#hud{
position:absolute;left:0;top:0;right:0;height:var(--hud-h);
display:flex;align-items:center;justify-content:space-between;
padding:10px 12px;
background:linear-gradient(180deg, rgba(0,20,40,0.9) 0%, rgba(0,10,20,0.7) 100%);
border-bottom:2px solid var(--accent);
box-shadow: 0 0 30px rgba(0,255,136,0.3), inset 0 -2px 20px rgba(0,255,136,0.1);
z-index:5;
backdrop-filter: blur(10px);
gap:10px;
user-select:none;
}

.hud-left,.hud-right{display:flex;align-items:center;gap:12px;flex-wrap:wrap}

.chip{
padding:8px 14px;border-radius:4px;
background:linear-gradient(135deg, rgba(0,255,136,.15) 0%, rgba(0,212,255,.1) 100%);
border:1px solid var(--border);
font-family: 'Orbitron', monospace;
font-weight:700;
font-size:13px;
letter-spacing:1px;
white-space:nowrap;
transition: all 0.3s ease;
text-shadow: 0 0 10px var(--accent);
box-shadow: 0 0 15px rgba(0,255,136,0.2);
}

.chip.pulse{animation: chipPulse 0.5s ease;}
.chip.danger{border-color: var(--danger); background: rgba(255,60,60,.2); animation: dangerPulse 0.3s ease;}

@keyframes chipPulse {
0%, 100% { transform: scale(1); }
50% { transform: scale(1.15); box-shadow: 0 0 30px var(--accent), 0 0 60px var(--accent2); }
}

@keyframes dangerPulse {
0%, 100% { transform: scale(1); }
50% { transform: scale(1.1); box-shadow: 0 0 30px var(--danger); }
}

.chip small{font-weight:600;color:var(--muted);font-size:11px}
#livesWrap{display:flex;align-items:center;gap:8px}
.heart{font-size:18px;line-height:1;filter:drop-shadow(0 0 5px #ff3b3b)}

/* MINI TOAST NOTIFICATIONS - Non-intrusive edge notifications */
#toastContainer{
position:absolute;
top:calc(var(--hud-h) + 8px);
left:50%;
transform:translateX(-50%);
display:flex;
flex-direction:column;
align-items:center;
gap:4px;
z-index:15;
pointer-events:none;
max-width:200px;
}

.mini-toast{
padding:4px 12px;
background:rgba(0,0,0,.7);
border:1px solid var(--accent);
border-radius:12px;
font-family: 'Orbitron', monospace;
font-size:11px;
font-weight:700;
color:var(--text);
white-space:nowrap;
animation: toastIn 0.3s ease, toastOut 0.3s ease 1.2s forwards;
text-shadow: 0 0 8px var(--accent);
}

.mini-toast.gold{border-color:var(--gold);color:var(--gold);text-shadow:0 0 8px var(--gold);}
.mini-toast.pink{border-color:var(--neon-pink);color:var(--neon-pink);text-shadow:0 0 8px var(--neon-pink);}
.mini-toast.cyan{border-color:var(--neon-blue);color:var(--neon-blue);text-shadow:0 0 8px var(--neon-blue);}
.mini-toast.danger{border-color:var(--danger);color:var(--danger);text-shadow:0 0 8px var(--danger);}

@keyframes toastIn {
0% { transform: translateY(-10px) scale(0.8); opacity: 0; }
100% { transform: translateY(0) scale(1); opacity: 1; }
}

@keyframes toastOut {
0% { opacity: 1; }
100% { opacity: 0; transform: translateY(-5px); }
}

/* V9: Pulse animation for expiring temporary upgrades */
@keyframes pulse {
0%, 100% { opacity: 1; transform: scale(1); }
50% { opacity: 0.7; transform: scale(1.05); }
}

/* Multiplier bar - bottom left corner */
#multiplierBar{
position:absolute;
bottom:calc((var(--vh, 1vh) * var(--controls-vh)) + 8px);
left:8px;
width:80px;
z-index:6;
opacity:0;
transition: opacity 0.3s ease;
}

#multiplierBar.active{opacity:1;}

#multiplierBar .mult-label{
font-family:'Orbitron',monospace;
font-size:10px;
font-weight:700;
color:var(--gold);
text-shadow:0 0 6px var(--gold);
margin-bottom:2px;
}

#multiplierBar .mult-track{
height:6px;
background:rgba(0,0,0,.5);
border:1px solid rgba(255,215,0,.4);
border-radius:3px;
overflow:hidden;
}

#multiplierBar .mult-fill{
height:100%;
background:linear-gradient(90deg, #ffd700, #ff8800);
transition:width 0.2s ease;
box-shadow:0 0 8px rgba(255,215,0,.5);
}

/* Near miss edge flash - subtle */
#nearMissIndicator{
position:absolute;
inset:0;
pointer-events:none;
z-index:4;
border:3px solid transparent;
transition:border-color 0.1s ease;
}

#nearMissIndicator.flash{
border-color:rgba(0,255,255,0.4);
animation: edgeFlash 0.2s ease;
}

@keyframes edgeFlash {
0% { border-color: rgba(0,255,255,0.6); }
100% { border-color: transparent; }
}

/* Risk zone indicator - bottom bar */
#riskIndicator{
position:absolute;
bottom:calc((var(--vh, 1vh) * var(--controls-vh)) + 8px);
right:8px;
padding:3px 8px;
background:rgba(255,0,102,.15);
border:1px solid var(--neon-pink);
border-radius:4px;
font-family: 'Orbitron', monospace;
font-size:9px;
color:var(--neon-pink);
z-index:6;
opacity:0;
transition: opacity 0.3s ease;
}

#riskIndicator.active{
opacity:1;
animation: riskPulse 0.5s ease infinite;
}

@keyframes riskPulse {
0%, 100% { box-shadow: 0 0 5px rgba(255,0,102,.3); }
50% { box-shadow: 0 0 12px rgba(255,0,102,.6); }
}

/* Revenge mode - small corner badge */
#revengeBadge{
position:absolute;
top:calc(var(--hud-h) + 8px);
left:8px;
padding:3px 8px;
background:rgba(255,0,0,.2);
border:1px solid var(--danger);
border-radius:4px;
font-family: 'Orbitron', monospace;
font-size:9px;
font-weight:900;
color:var(--danger);
z-index:6;
opacity:0;
transition: opacity 0.3s ease;
}

#revengeBadge.active{
opacity:1;
animation: revengePulse 0.3s ease infinite;
}

@keyframes revengePulse {
0%, 100% { box-shadow: 0 0 8px rgba(255,0,0,.4); }
50% { box-shadow: 0 0 16px rgba(255,0,0,.7); }
}

#xpBarContainer{position:absolute;top:var(--hud-h);left:0;right:0;height:8px;background:rgba(0,0,0,.7);border-bottom:1px solid rgba(0,255,204,.3);z-index:5}
#xpBarFill{height:100%;width:0%;background:linear-gradient(90deg,#00ffcc,#00ff88,#88ff00);box-shadow:0 0 10px rgba(0,255,204,.5);transition:width 0.3s ease}
#xpBarText{position:absolute;right:8px;top:50%;transform:translateY(-50%);font-family:'Orbitron',monospace;font-size:7px;font-weight:700;color:#00ffcc;text-shadow:0 0 4px #00ffcc}
#levelBadge{position:absolute;top:calc(var(--hud-h) + 12px);left:8px;padding:4px 10px;background:linear-gradient(135deg,rgba(0,255,204,.2),rgba(0,255,136,.1));border:1px solid #00ffcc;border-radius:4px;font-family:'Orbitron',monospace;font-size:11px;font-weight:900;color:#00ffcc;text-shadow:0 0 8px #00ffcc;z-index:6}
#levelBadge.levelup{animation:badgeLevelUp 1s ease}
@keyframes badgeLevelUp{0%{transform:scale(1)}30%{transform:scale(1.5);box-shadow:0 0 30px var(--gold);border-color:var(--gold)}100%{transform:scale(1)}}
#missileIndicator{position:absolute;top:calc(var(--hud-h) + 12px);right:8px;padding:4px 10px;background:rgba(255,100,0,.15);border:1px solid #ff6600;border-radius:4px;font-family:'Orbitron',monospace;font-size:10px;font-weight:700;color:#ff6600;text-shadow:0 0 6px #ff6600;z-index:6;opacity:0;transition:opacity 0.3s ease}
#missileIndicator.active{opacity:1}

#powerupBar{
position:absolute;
top:calc(var(--hud-h) + 10px);
right:8px;
display:flex;
flex-direction:column;
gap:4px;
z-index:6;
max-width: 110px;
}

.powerup-active{
padding:4px 8px;
background:linear-gradient(90deg, rgba(0,212,255,.2) 0%, rgba(157,0,255,.15) 100%);
border:1px solid var(--accent2);
border-radius:4px;
font-family: 'Orbitron', monospace;
font-size:9px;
font-weight:700;
display:flex;
align-items:center;
gap:4px;
box-shadow: 0 0 8px rgba(0,212,255,0.3);
}

.powerup-timer{
width:30px;height:3px;
background:rgba(255,255,255,.15);
border-radius:2px;overflow:hidden;
}

.powerup-timer-fill{
height:100%;
background:linear-gradient(90deg, var(--accent2), var(--neon-purple));
transition:width 0.1s linear;
}

.powerup-active.warning{
animation: shieldWarnBlink 0.22s step-end infinite;
border-color: var(--danger) !important;
}
@keyframes shieldWarnBlink{ 50%{ opacity:0.35; } }

/* Wave announcement - smaller, top center */
#waveAnnounce{
position:absolute;
top:calc(var(--hud-h) + 40px);
left:50%;
transform:translateX(-50%) scale(0);
font-family: 'Orbitron', monospace;
font-size:clamp(18px, 5vw, 28px);
font-weight:900;
color:var(--text);
text-shadow: 0 0 15px var(--accent), 0 0 30px var(--accent2);
z-index:15;
pointer-events:none;
opacity:0;
transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}

#waveAnnounce.show{transform:translateX(-50%) scale(1);opacity:1;}
#waveAnnounce.boss{color:var(--danger);text-shadow: 0 0 15px var(--danger), 0 0 30px #ff6600;}

#controlArea{
position:absolute;left:0;right:0;bottom:0;
height:calc(var(--vh, 1vh) * var(--controls-vh)); padding-bottom: env(safe-area-inset-bottom);
display:flex;align-items:center;justify-content:space-between;
padding:0 5vw;
z-index:10;
background:linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,20,40,.5) 30%, rgba(0,40,60,.7) 100%);
}

#joystickContainer{
width:min(18vh,180px);
height:min(18vh,180px);
position:relative;
touch-action:none;
}

.joystick-base{
width:100%;height:100%;
border-radius:50%;
border:2px solid var(--border);
background:radial-gradient(circle, rgba(0,255,136,.12) 0%, rgba(0,255,136,.03) 100%);
display:flex;align-items:center;justify-content:center;
box-shadow:0 0 30px rgba(0,255,136,.2), inset 0 0 30px rgba(0,255,136,.1);
}

.joystick-stick{
width:50%;height:50%;
border-radius:50%;
border:2px solid rgba(0,255,136,.7);
background:radial-gradient(circle, rgba(0,255,136,.4) 0%, rgba(0,255,136,.15) 100%);
box-shadow:0 0 25px rgba(0,255,136,.5);
transform:translate(0,0);
transition:transform .04s linear;
}

#fireButton{
width:min(15vh,150px);
height:min(15vh,150px);
border-radius:50%;
border:3px solid rgba(255,60,60,.7);
background:radial-gradient(circle, rgba(255,60,60,.35) 0%, rgba(255,30,30,.15) 100%);
box-shadow:0 0 30px rgba(255,60,60,.4), inset 0 0 20px rgba(255,60,60,.2);
display:flex;align-items:center;justify-content:center;
font-family: 'Orbitron', monospace;
font-weight:900;font-size:16px;letter-spacing:2px;
user-select:none;
touch-action:none;
transform:translateZ(0);
transition: all 0.1s ease;
text-shadow: 0 0 15px rgba(255,60,60,0.8);
}

#fireButton:active{
transform:scale(.9);
box-shadow:0 0 50px rgba(255,60,60,.7), 0 0 80px rgba(255,100,100,.5);
background:radial-gradient(circle, rgba(255,100,100,.5) 0%, rgba(255,60,60,.3) 100%);
}

#overlay{
position:absolute;inset:0;
display:none;
align-items:center;justify-content:center;
z-index:20;
background:radial-gradient(ellipse at center, rgba(0,20,40,.85) 0%, rgba(0,0,0,.95) 100%);
backdrop-filter: blur(8px);
text-align:center;
padding:24px;
}

#overlay .box{
max-width:580px;width:100%;
border:2px solid var(--accent);
background:linear-gradient(135deg, rgba(0,40,60,.9) 0%, rgba(0,20,40,.95) 100%);
border-radius:12px;
padding:24px 20px;
box-shadow:0 0 60px rgba(0,255,136,.3), 0 0 120px rgba(0,212,255,.2);
}

#overlay h2{
font-family: 'Orbitron', monospace;
font-size:28px;
margin-bottom:12px;
text-shadow: 0 0 20px var(--accent), 0 0 40px var(--accent2);
letter-spacing: 3px;
}

#overlay p{color:var(--muted);font-size:14px;line-height:1.5;margin-bottom:15px;}

#overlay .stats{display:flex;justify-content:center;gap:30px;margin:20px 0;flex-wrap:wrap;}
#overlay .stat{text-align:center;}
#overlay .stat-value{font-family: 'Orbitron', monospace;font-size:32px;font-weight:900;color:var(--gold);text-shadow: 0 0 20px var(--gold);}
#overlay .stat-label{font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:2px;}

#overlay button{
margin-top:16px;
padding:14px 28px;
border-radius:6px;
border:2px solid var(--accent);
background:linear-gradient(135deg, rgba(0,255,136,.2) 0%, rgba(0,212,255,.15) 100%);
color:var(--text);
font-family: 'Orbitron', monospace;
font-weight:700;
font-size:14px;
letter-spacing:2px;
cursor:pointer;
transition:all 0.3s ease;
text-shadow: 0 0 10px var(--accent);
}

#overlay button:hover{
background:linear-gradient(135deg, rgba(0,255,136,.35) 0%, rgba(0,212,255,.3) 100%);
box-shadow:0 0 30px rgba(0,255,136,.5);
transform: translateY(-2px);
}

.kbd{display:none;color:var(--muted);font-size:12px;margin-top:12px;}
@media (hover:hover) and (pointer:fine){.kbd{display:block}}

#highscoreSection{margin-top:20px;padding-top:20px;border-top:1px solid var(--border);}
#highscoreSection h3{font-family: 'Orbitron', monospace;font-size:16px;margin-bottom:15px;color:var(--gold);text-shadow: 0 0 15px var(--gold);letter-spacing:2px;}
#highscoreTable{width:100%;max-width:350px;margin:0 auto;font-family: 'Rajdhani', monospace;}
.hs-row{display:flex;justify-content:space-between;padding:6px 12px;border-bottom:1px solid rgba(0,255,136,.15);font-size:14px;}
.hs-row.highlight{background:linear-gradient(90deg, rgba(255,215,0,.2) 0%, rgba(255,215,0,.05) 100%);border:1px solid var(--gold);border-radius:4px;animation: highlightPulse 1s ease infinite;}
@keyframes highlightPulse {0%, 100% { box-shadow: 0 0 10px rgba(255,215,0,.3); }50% { box-shadow: 0 0 25px rgba(255,215,0,.6); }}
.hs-rank{width:30px;color:var(--accent);font-weight:700;}
.hs-name{flex:1;text-align:left;padding-left:15px;font-family: 'Orbitron', monospace;letter-spacing:3px;}
.hs-score{font-weight:700;color:var(--gold);}

#nameEntry{display:none;margin:25px 0;padding:20px;background:linear-gradient(135deg, rgba(255,215,0,.1) 0%, rgba(255,100,0,.05) 100%);border:2px solid var(--gold);border-radius:8px;}
#nameEntry h4{font-family: 'Orbitron', monospace;font-size:14px;margin-bottom:15px;color:var(--gold);text-shadow: 0 0 15px var(--gold);}
#nameInputDisplay{display:flex;justify-content:center;gap:12px;margin-bottom:15px;}
.name-char{width:50px;height:60px;background:rgba(0,0,0,.5);border:2px solid var(--accent);border-radius:6px;display:flex;align-items:center;justify-content:center;font-family: 'Orbitron', monospace;font-size:32px;font-weight:900;color:var(--text);text-shadow: 0 0 15px var(--accent);}
.name-char.active{border-color:var(--gold);box-shadow: 0 0 20px var(--gold);animation: charBlink 0.5s ease infinite;}
@keyframes charBlink {0%, 100% { background: rgba(255,215,0,.1); }50% { background: rgba(255,215,0,.25); }}
#nameControls{display:flex;justify-content:center;gap:10px;flex-wrap:wrap;}
#nameControls button{padding:10px 18px;font-size:16px;min-width:50px;}

.screenOverlay{position:absolute;inset:0;display:none;z-index:30;background:linear-gradient(180deg, rgba(0,0,0,.92), rgba(0,0,0,.75));backdrop-filter: blur(8px);align-items:center;justify-content:center;padding:18px;}
.screenOverlay.active{display:flex;}
.screenBox{width:min(560px, 94vw);border:1px solid var(--border);background:rgba(0,255,136,.06);border-radius:18px;padding:18px 16px;box-shadow:0 0 34px rgba(0,0,0,.35);text-align:center;}
.screenTitle{font-family:'Orbitron','Rajdhani',ui-monospace,monospace;font-weight:900;letter-spacing:2px;margin:6px 0 10px;font-size:28px;color:var(--accent);text-shadow:0 0 18px rgba(0,255,136,.45);}
.screenSub{color:var(--muted);margin:0 0 10px;font-size:14px}
.menuBtns{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:12px}
.menuBtns button{padding:10px 14px;border-radius:12px;border:1px solid var(--border);background:rgba(0,255,136,.12);color:var(--text);font-weight:900;cursor:pointer;transition:all 0.2s ease;font-family: inherit;}
.menuBtns button:hover{background:rgba(0,255,136,.25);box-shadow:0 0 20px rgba(0,255,136,.3);}
#startHighscoreTable, #highScoreList{margin-top:10px;max-height:min(48vh, 360px);overflow:auto;border-radius:14px;border:1px solid rgba(0,255,136,.18);background:rgba(0,0,0,.25);}

@media (orientation: landscape) and (max-height: 520px){:root{ --controls-vh: 16; }}
@media (max-width: 420px){:root{ --controls-vh: 20; }}


/* =======================
   MILESTONE UPGRADES UI
   ======================= */
.upgradeBox{max-width:620px}
.upgradeGrid{display:grid;grid-template-columns:repeat(2, minmax(0,1fr));gap:12px;margin-top:14px}
.upgradeCard{
  appearance:none;border:1px solid var(--border);background:rgba(0,0,0,.45);
  border-radius:16px;padding:14px 12px;color:var(--text);text-align:left;
  box-shadow:0 0 24px rgba(0,0,0,.25);cursor:pointer;
}
.upgradeCard:hover{border-color:rgba(0,255,136,.65);transform:translateY(-1px)}

.upHead{display:flex;align-items:center;justify-content:space-between;gap:10px}
.tierBadge{
  font-family:'Orbitron','Rajdhani',ui-monospace,monospace;
  font-weight:900;letter-spacing:.08em;font-size:11px;
  padding:4px 8px;border-radius:999px;border:1px solid var(--border);
  background:rgba(0,0,0,.25);color:var(--text);flex:0 0 auto
}
.tier-common{border-color:rgba(234,255,246,.25)}
.tier-rare{border-color:rgba(0,212,255,.55);color:rgba(0,212,255,.95)}
.tier-epic{border-color:rgba(255,0,255,.55);color:rgba(255,0,255,.95)}

.upName{font-family:'Orbitron','Rajdhani',ui-monospace,monospace;font-weight:900;letter-spacing:.06em;font-size:14px;color:var(--accent)}
.upDesc{margin-top:6px;color:var(--muted);font-size:14px;line-height:1.25}
.upMeta{margin-top:10px;font-size:12px;color:rgba(234,255,246,.75)}
#btnUpgradeReroll[disabled]{opacity:.45;filter:grayscale(1);cursor:not-allowed}
@media (max-width:520px){
  .upgradeGrid{grid-template-columns:1fr}
}


.debug-chip{
  border:1px solid rgba(0,255,204,0.35);
  background:rgba(0,0,0,0.35);
  cursor:pointer;
  user-select:none;
}
.debug-chip:active{ transform: translateY(1px); }

/* ============================================================
   LOOT SYSTEM STYLES - V9 INTEGRATION
   ============================================================ */

/* RARITY TOAST COLORS */
.mini-toast.rarity-normal{border-color:var(--rarity-normal);color:var(--rarity-normal);}
.mini-toast.rarity-rare{border-color:var(--rarity-rare);color:var(--rarity-rare);}
.mini-toast.rarity-epic{border-color:var(--rarity-epic);color:var(--rarity-epic);}
.mini-toast.rarity-legendary{border-color:var(--rarity-legendary);color:var(--rarity-legendary);animation:toastLegendary 0.3s ease, toastOut 0.3s ease 2s forwards;}
.mini-toast.rarity-mythic{border-color:var(--rarity-mythic);color:var(--rarity-mythic);animation:toastMythic 0.5s ease, toastOut 0.3s ease 2.5s forwards;}

@keyframes toastLegendary {
0% { transform: scale(0.5); opacity: 0; }
50% { transform: scale(1.3); }
100% { transform: scale(1); opacity: 1; }
}

@keyframes toastMythic {
0% { transform: scale(0.5) rotate(-10deg); opacity: 0; }
30% { transform: scale(1.4) rotate(5deg); }
60% { transform: scale(0.9) rotate(-3deg); }
100% { transform: scale(1) rotate(0deg); opacity: 1; }
}

/* SCRAP DISPLAY */
#scrapDisplay{
  display:flex;
  align-items:center;
  gap:4px;
  padding:4px 10px;
  background:linear-gradient(135deg, rgba(245,158,11,.15), rgba(251,191,36,.1));
  border:1px solid rgba(245,158,11,.4);
  border-radius:4px;
  font-family:'Orbitron',monospace;
  font-size:11px;
  font-weight:700;
  color:var(--gold);
  text-shadow:0 0 6px var(--gold);
}

/* LOOT DROP NOTIFICATION */
.loot-drop-notification{
  position:fixed;
  top:50%;
  left:50%;
  transform:translate(-50%, -50%);
  z-index:100;
  text-align:center;
  pointer-events:none;
  animation:lootDropIn 0.6s ease, lootDropOut 0.4s ease 1.8s forwards;
}

.loot-drop-notification .rarity-label{
  font-family:'Orbitron',monospace;
  font-size:14px;
  font-weight:700;
  letter-spacing:3px;
  margin-bottom:8px;
  text-transform:uppercase;
}

.loot-drop-notification .item-name{
  font-family:'Orbitron',monospace;
  font-size:28px;
  font-weight:900;
  text-shadow:0 0 30px currentColor;
  margin-bottom:10px;
}

.loot-drop-notification .item-icon{
  font-size:64px;
  margin-bottom:10px;
}

.loot-drop-notification .item-desc{
  font-size:14px;
  opacity:0.8;
  max-width:300px;
}

@keyframes lootDropIn {
0% { transform: translate(-50%, -50%) scale(0) rotate(-20deg); opacity: 0; }
50% { transform: translate(-50%, -50%) scale(1.2) rotate(5deg); }
100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
}

@keyframes lootDropOut {
0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8) translateY(-30px); }
}

/* CAPSULE NOTIFICATION */
.capsule-notification{
  position:fixed;
  top:50%;
  left:50%;
  transform:translate(-50%, -50%);
  z-index:110;
  padding:40px 60px;
  background:radial-gradient(circle, rgba(30,40,70,0.95), rgba(10,15,30,0.98));
  border:3px solid;
  border-radius:20px;
  text-align:center;
  animation:capsuleIn 0.8s ease;
}

.capsule-notification.golden{
  border-color:var(--gold);
  box-shadow:0 0 60px rgba(245,158,11,0.6), inset 0 0 40px rgba(245,158,11,0.2);
}

.capsule-notification.mythic{
  border-color:var(--rarity-mythic);
  box-shadow:0 0 80px rgba(236,72,153,0.7), inset 0 0 50px rgba(236,72,153,0.3);
  animation:capsuleIn 0.8s ease, mythicPulse 1.5s ease infinite;
}

@keyframes capsuleIn {
0% { transform: translate(-50%, -50%) scale(0) rotate(-180deg); opacity: 0; }
60% { transform: translate(-50%, -50%) scale(1.1) rotate(10deg); }
100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 1; }
}

@keyframes mythicPulse {
0%, 100% { box-shadow: 0 0 80px rgba(236,72,153,0.7), inset 0 0 50px rgba(236,72,153,0.3); }
50% { box-shadow: 0 0 120px rgba(236,72,153,0.9), inset 0 0 70px rgba(236,72,153,0.5); }
}

/* ACTIVE UPGRADES PANEL */
#activeUpgradesPanel{
  position:absolute;
  top:calc(var(--hud-h) + 40px);
  left:8px;
  max-width:140px;
  z-index:6;
  display:flex;
  flex-direction:column;
  gap:3px;
}

.upgrade-badge{
  padding:3px 8px;
  background:rgba(30,40,70,0.8);
  border-radius:4px;
  font-family:'Orbitron',monospace;
  font-size:9px;
  font-weight:700;
  display:flex;
  align-items:center;
  gap:6px;
  border:1px solid rgba(100,200,255,0.3);
}

.upgrade-badge.temporary{border-color:rgba(96,165,250,0.5);color:#60A5FA;}
.upgrade-badge.runPersistent{border-color:rgba(139,92,246,0.5);color:#8B5CF6;}
.upgrade-badge.permanent{border-color:rgba(236,72,153,0.5);color:#EC4899;}

/* DEBRIEF SCREEN ENHANCEMENTS */
.debrief-loot-grid{
  display:grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap:15px;
  margin:15px 0;
}

.debrief-loot-card{
  padding:15px;
  background:linear-gradient(135deg, rgba(30,40,70,0.8), rgba(20,30,50,0.9));
  border:2px solid;
  border-radius:12px;
  text-align:center;
  transition:all 0.3s ease;
}

.debrief-loot-card:hover{
  transform:translateY(-3px);
  box-shadow:0 8px 25px rgba(100,200,255,0.3);
}

.debrief-loot-card .loot-icon{font-size:36px;margin:10px 0;}
.debrief-loot-card .loot-name{font-size:14px;font-weight:700;margin-bottom:5px;}
.debrief-loot-card .loot-desc{font-size:11px;opacity:0.7;line-height:1.4;}
.debrief-loot-card .loot-type{font-size:9px;letter-spacing:1px;margin-top:8px;padding:3px 8px;border-radius:10px;display:inline-block;}

.loot-type.temporary{background:rgba(96,165,250,0.2);color:#60A5FA;}
.loot-type.runPersistent{background:rgba(139,92,246,0.2);color:#8B5CF6;}
.loot-type.permanent{background:rgba(236,72,153,0.2);color:#EC4899;}

/* V9: Loot Inventory Cards (Debrief) */
.loot-inv-card{
  display:flex;
  align-items:center;
  gap:8px;
  padding:8px 12px;
  background:rgba(0,0,0,0.3);
  border:1px solid;
  border-radius:8px;
  font-size:11px;
}
.loot-inv-card .loot-icon{font-size:20px;}
.loot-inv-card .loot-info{flex:1;text-align:left;}
.loot-inv-card .loot-name{font-weight:700;font-size:11px;}
.loot-inv-card .loot-desc{font-size:9px;opacity:0.7;}
.loot-inv-card .loot-actions{display:flex;gap:4px;}
.loot-inv-card button{
  padding:4px 8px;
  border:1px solid;
  background:rgba(0,0,0,0.3);
  color:#fff;
  border-radius:4px;
  font-size:9px;
  font-family:'Orbitron',monospace;
  cursor:pointer;
  transition:all 0.2s;
}
.loot-inv-card button:hover{transform:translateY(-1px);box-shadow:0 2px 8px rgba(0,255,136,0.3);}
.loot-inv-card button.apply-btn{border-color:#00ff88;color:#00ff88;}
.loot-inv-card button.sell-btn{border-color:#ffd700;color:#ffd700;}
.loot-inv-card button.buy-btn{border-color:#00d4ff;color:#00d4ff;}
.loot-inv-card button:disabled{opacity:0.5;cursor:not-allowed;}

/* Rarity borders for loot cards */
.loot-inv-card.rarity-normal{border-color:rgba(156,163,175,0.5);}
.loot-inv-card.rarity-rare{border-color:rgba(59,130,246,0.5);}
.loot-inv-card.rarity-epic{border-color:rgba(139,92,246,0.7);}
.loot-inv-card.rarity-legendary{border-color:rgba(245,158,11,0.8);box-shadow:0 0 10px rgba(245,158,11,0.3);}
.loot-inv-card.rarity-mythic{border-color:rgba(236,72,153,0.9);box-shadow:0 0 15px rgba(236,72,153,0.4);animation:mythicGlow 2s infinite;}

/* V10: Equipment Slots */
.equip-slot{background:rgba(0,0,0,0.5);border:2px solid rgba(139,92,246,0.3);border-radius:10px;padding:10px;text-align:center;cursor:pointer;transition:all 0.2s;}
.equip-slot:hover{background:rgba(139,92,246,0.15);border-color:#8B5CF6;transform:translateY(-2px);}
.equip-slot.filled{border-color:rgba(0,255,136,0.5);background:rgba(0,255,136,0.05);}
.equip-slot .slot-icon{font-size:22px;margin-bottom:4px;}
.equip-slot .slot-name{font-size:9px;color:#888;margin-bottom:4px;}
.equip-slot .slot-item{font-size:10px;color:#8B5CF6;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}

/* Pilot-specific slots */
.equip-slot.pilot-slot{border-color:rgba(236,72,153,0.3);}
.equip-slot.pilot-slot:hover{background:rgba(236,72,153,0.15);border-color:#EC4899;}
.equip-slot.pilot-slot.filled{border-color:rgba(236,72,153,0.6);background:rgba(236,72,153,0.1);}
.equip-slot.pilot-slot .slot-item{color:#EC4899;}

/* Equipment tabs */
.equip-tab{transition:all 0.2s;}
.equip-tab:hover{transform:translateY(-2px);}
.equip-tab.active{font-weight:700;}

.stash-item{background:rgba(0,0,0,0.4);border:1px solid rgba(139,92,246,0.3);border-radius:6px;padding:8px;text-align:center;cursor:pointer;transition:all 0.2s;}
.stash-item:hover{background:rgba(139,92,246,0.15);transform:scale(1.03);}
.stash-item .item-icon{font-size:18px;}
.stash-item .item-name{font-size:9px;margin-top:3px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.stash-item.rarity-normal{border-color:#9CA3AF;}
.stash-item.rarity-rare{border-color:#3B82F6;}
.stash-item.rarity-epic{border-color:#8B5CF6;}
.stash-item.rarity-legendary{border-color:#F59E0B;box-shadow:0 0 6px rgba(245,158,11,0.3);}
.stash-item.rarity-mythic{border-color:#EC4899;box-shadow:0 0 8px rgba(236,72,153,0.4);}

@keyframes mythicGlow{
  0%,100%{box-shadow:0 0 15px rgba(236,72,153,0.4);}
  50%{box-shadow:0 0 25px rgba(236,72,153,0.7);}
}

.grade-display{
  font-size:72px;
  font-weight:900;
  text-shadow:0 0 40px currentColor;
  margin:15px 0;
}

.grade-D{color:#9CA3AF;}
.grade-C{color:#60A5FA;}
.grade-B{color:#8B5CF6;}
.grade-A{color:#FBBF24;}
.grade-S{color:#F59E0B;animation:gradeGlow 1s ease infinite;}
.grade-SS{color:#EC4899;animation:gradeMythic 0.5s ease infinite;}

@keyframes gradeGlow {
0%, 100% { text-shadow: 0 0 40px currentColor; }
50% { text-shadow: 0 0 60px currentColor, 0 0 80px currentColor; }
}

@keyframes gradeMythic {
0%, 100% { text-shadow: 0 0 40px currentColor; transform: scale(1); }
50% { text-shadow: 0 0 80px currentColor, 0 0 120px currentColor; transform: scale(1.05); }
}

</style>

</head>
<body>

<div id="startScreen" class="screenOverlay active">
<div class="screenBox" style="max-width:750px;">
<div class="screenTitle" style="font-size:36px;background:linear-gradient(90deg,#00ff88,#00d4ff);-webkit-background-clip:text;-webkit-text-fill-color:transparent;text-shadow:none;">M4NFROID</div>
<p class="screenSub" style="color:#00d4ff;font-size:13px;margin-bottom:12px;">GALACTICA v9.2 - LOOT SYSTEM EDITION</p>

<!-- Ship Selection Panel -->
<div id="shipSelectPanel" style="background:linear-gradient(135deg,rgba(0,50,100,0.3),rgba(0,30,60,0.4));border:1px solid rgba(0,212,255,0.3);border-radius:12px;padding:15px;margin:12px 0;">
  <div style="color:#00d4ff;font-size:12px;font-weight:700;margin-bottom:12px;display:flex;justify-content:space-between;align-items:center;">
    <span>üöÄ SELECT SHIP</span>
    <span id="selectedShipName" style="color:#00ff88;">Default Fighter</span>
  </div>
  <div id="shipSelectGrid" style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap;">
    <!-- Ships will be rendered here -->
    <div class="ship-option selected" data-ship="default" style="width:70px;height:70px;background:rgba(0,0,0,0.4);border:2px solid #00ff88;border-radius:10px;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:.2s;">
      <div style="font-size:32px;">üöÄ</div>
    </div>
    <div class="ship-option locked" data-ship="stealth" style="width:70px;height:70px;background:rgba(0,0,0,0.4);border:2px solid rgba(255,255,255,0.2);border-radius:10px;display:flex;align-items:center;justify-content:center;cursor:pointer;opacity:0.5;">
      <div style="font-size:32px;">üîí</div>
    </div>
    <div class="ship-option locked" data-ship="heavy" style="width:70px;height:70px;background:rgba(0,0,0,0.4);border:2px solid rgba(255,255,255,0.2);border-radius:10px;display:flex;align-items:center;justify-content:center;cursor:pointer;opacity:0.5;">
      <div style="font-size:32px;">üîí</div>
    </div>
  </div>
</div>

<!-- Skin Selection Panel -->
<div id="skinSelectPanel" style="background:linear-gradient(135deg,rgba(100,50,0,0.2),rgba(80,40,0,0.3));border:1px solid rgba(255,170,0,0.3);border-radius:12px;padding:15px;margin:12px 0;">
  <div style="color:#ffaa00;font-size:12px;font-weight:700;margin-bottom:12px;display:flex;justify-content:space-between;align-items:center;">
    <span>üé® SELECT SKIN</span>
    <span id="selectedSkinName" style="color:#ffd700;">Default</span>
  </div>
  <div id="skinSelectGrid" style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap;">
    <div class="skin-option selected" data-skin="default" style="width:50px;height:50px;background:linear-gradient(135deg,#444,#222);border:2px solid #ffd700;border-radius:8px;cursor:pointer;">
      <div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:10px;color:#aaa;">STD</div>
    </div>
    <div class="skin-option locked" data-skin="chrome" style="width:50px;height:50px;background:linear-gradient(135deg,#888,#444);border:2px solid rgba(255,255,255,0.2);border-radius:8px;cursor:pointer;opacity:0.5;">
      <div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:18px;">üîí</div>
    </div>
    <div class="skin-option locked" data-skin="inferno" style="width:50px;height:50px;background:linear-gradient(135deg,#ff6600,#ff3300);border:2px solid rgba(255,255,255,0.2);border-radius:8px;cursor:pointer;opacity:0.5;">
      <div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:18px;">üîí</div>
    </div>
    <div class="skin-option locked" data-skin="void" style="width:50px;height:50px;background:linear-gradient(135deg,#220033,#000);border:2px solid rgba(255,255,255,0.2);border-radius:8px;cursor:pointer;opacity:0.5;">
      <div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:18px;">üîí</div>
    </div>
  </div>
</div>

<!-- Loadout / Permanent Upgrades Panel -->
<div id="loadoutPanel" style="background:linear-gradient(135deg,rgba(139,92,246,0.15),rgba(100,60,180,0.2));border:1px solid rgba(139,92,246,0.3);border-radius:12px;padding:15px;margin:12px 0;">
  <div style="color:#a78bfa;font-size:12px;font-weight:700;margin-bottom:10px;display:flex;justify-content:space-between;align-items:center;">
    <span>‚öîÔ∏è LOADOUT</span>
    <span id="permanentUpgradeCount" style="color:#8B5CF6;">0 Upgrades</span>
  </div>
  <div id="loadoutGrid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(100px,1fr));gap:8px;max-height:80px;overflow-y:auto;">
    <div style="text-align:center;color:#666;font-size:10px;padding:15px;">No permanent upgrades yet</div>
  </div>
</div>

<!-- Stats Summary -->
<div id="startStatsPanel" style="display:flex;justify-content:space-around;gap:10px;margin:12px 0;padding:12px;background:rgba(0,0,0,0.3);border-radius:10px;">
  <div style="text-align:center;">
    <div id="startHighWave" style="font-size:22px;color:#00ff88;font-weight:900;">0</div>
    <div style="font-size:9px;color:#888;">BEST WAVE</div>
  </div>
  <div style="text-align:center;">
    <div id="startTotalScrapValue" style="font-size:22px;color:#ffd700;font-weight:900;">0</div>
    <div style="font-size:9px;color:#888;">üí∞ SCRAP</div>
  </div>
  <div style="text-align:center;">
    <div id="startTotalRuns" style="font-size:22px;color:#00d4ff;font-weight:900;">0</div>
    <div style="font-size:9px;color:#888;">RUNS</div>
  </div>
  <div style="text-align:center;">
    <div id="startTotalKills" style="font-size:22px;color:#ff6666;font-weight:900;">0</div>
    <div style="font-size:9px;color:#888;">KILLS</div>
  </div>
</div>

<!-- Action Buttons -->
<div class="menuBtns" style="gap:10px;flex-wrap:wrap;">
  <button id="btnStart" style="background:linear-gradient(135deg,rgba(0,255,136,0.2),rgba(0,212,255,0.2));border-color:#00ff88;flex:2;">‚ñ∂ START MISSION</button>
  <button id="btnOpenVendor" style="border-color:#ffaa00;color:#ffaa00;">ü™ô SHOP</button>
  <button id="btnOpenEquipment" style="border-color:#8B5CF6;color:#8B5CF6;">‚öîÔ∏è EQUIP</button>
  <button id="btnOpenHighscores" style="border-color:#888;">üèÜ</button>
</div>

<div style="font-size:9px;color:#555;margin-top:10px;">Arrow keys or WASD to move ‚Ä¢ Space to fire ‚Ä¢ P = Inventory</div>
</div>
</div>

<!-- V10: Equipment Screen with Ship/Pilot Tabs -->
<div id="equipmentScreen" class="screenOverlay">
<div class="screenBox" style="max-width:950px;">
  <div class="screenTitle" style="font-size:28px;background:linear-gradient(90deg,#8B5CF6,#EC4899);-webkit-background-clip:text;-webkit-text-fill-color:transparent;">‚öîÔ∏è EQUIPMENT</div>
  
  <!-- Currency Display -->
  <div style="text-align:center;margin:10px 0;padding:10px;background:rgba(255,215,0,0.1);border:1px solid rgba(255,215,0,0.3);border-radius:8px;">
    <span style="color:#888;">YOUR SCRAP:</span>
    <span id="equipScrapDisplay" style="font-size:24px;color:#ffd700;font-weight:900;margin-left:10px;">0 üí∞</span>
  </div>
  
  <!-- Tab Switcher: Ship / Pilot -->
  <div style="display:flex;gap:5px;margin:15px 0 10px 0;">
    <button id="tabShipEquip" class="equip-tab active" onclick="switchEquipTab('ship')" style="flex:1;padding:12px;background:linear-gradient(135deg,rgba(0,255,136,0.2),rgba(0,212,255,0.2));border:2px solid #00ff88;border-radius:10px 10px 0 0;color:#00ff88;font-family:'Orbitron',monospace;font-size:13px;font-weight:700;cursor:pointer;">üöÄ SHIP</button>
    <button id="tabPilotEquip" class="equip-tab" onclick="switchEquipTab('pilot')" style="flex:1;padding:12px;background:rgba(236,72,153,0.1);border:2px solid rgba(236,72,153,0.3);border-radius:10px 10px 0 0;color:#888;font-family:'Orbitron',monospace;font-size:13px;cursor:pointer;">üë®‚ÄçüöÄ PILOT</button>
  </div>
  
  <!-- SHIP Equipment Panel -->
  <div id="shipEquipPanel" class="equip-panel">
    <div id="equipmentSlotsContainer" style="display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-bottom:15px;">
      <div class="equip-slot" data-slot="weapon" onclick="openSlotSelector('weapon')">
        <div class="slot-icon">‚öîÔ∏è</div>
        <div class="slot-name">Weapon</div>
        <div class="slot-item" id="slotWeapon">Empty</div>
      </div>
      <div class="equip-slot" data-slot="shield" onclick="openSlotSelector('shield')">
        <div class="slot-icon">üõ°Ô∏è</div>
        <div class="slot-name">Shield</div>
        <div class="slot-item" id="slotShield">Empty</div>
      </div>
      <div class="equip-slot" data-slot="engine" onclick="openSlotSelector('engine')">
        <div class="slot-icon">üöÄ</div>
        <div class="slot-name">Engine</div>
        <div class="slot-item" id="slotEngine">Empty</div>
      </div>
      <div class="equip-slot" data-slot="reactor" onclick="openSlotSelector('reactor')">
        <div class="slot-icon">‚ö°</div>
        <div class="slot-name">Reactor</div>
        <div class="slot-item" id="slotReactor">Empty</div>
      </div>
      <div class="equip-slot" data-slot="mod1" onclick="openSlotSelector('mod1')">
        <div class="slot-icon">üîß</div>
        <div class="slot-name">Mod 1</div>
        <div class="slot-item" id="slotMod1">Empty</div>
      </div>
      <div class="equip-slot" data-slot="mod2" onclick="openSlotSelector('mod2')">
        <div class="slot-icon">üîß</div>
        <div class="slot-name">Mod 2</div>
        <div class="slot-item" id="slotMod2">Empty</div>
      </div>
      <div class="equip-slot" data-slot="special" onclick="openSlotSelector('special')">
        <div class="slot-icon">‚≠ê</div>
        <div class="slot-name">Special</div>
        <div class="slot-item" id="slotSpecial">Empty</div>
      </div>
      <div class="equip-stats-box" style="background:rgba(0,255,136,0.1);border:1px solid rgba(0,255,136,0.3);border-radius:10px;padding:10px;">
        <div style="font-size:10px;color:#888;margin-bottom:6px;">SHIP BONUSES</div>
        <div style="display:flex;justify-content:space-between;padding:3px 0;font-size:11px;"><span>‚öîÔ∏è DMG</span><span id="equipStatDmg" style="color:#00ff88;">+0%</span></div>
        <div style="display:flex;justify-content:space-between;padding:3px 0;font-size:11px;"><span>üî´ RATE</span><span id="equipStatFire" style="color:#00ff88;">+0%</span></div>
        <div style="display:flex;justify-content:space-between;padding:3px 0;font-size:11px;"><span>üí® SPD</span><span id="equipStatSpd" style="color:#00ff88;">+0%</span></div>
      </div>
    </div>
  </div>
  
  <!-- PILOT Equipment Panel (Hidden by default) -->
  <div id="pilotEquipPanel" class="equip-panel" style="display:none;">
    <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-bottom:15px;">
      <div class="equip-slot pilot-slot" data-slot="helmet" onclick="openPilotSlotSelector('helmet')">
        <div class="slot-icon">ü™ñ</div>
        <div class="slot-name">Helmet</div>
        <div class="slot-item" id="slotHelmet">Empty</div>
      </div>
      <div class="equip-slot pilot-slot" data-slot="suit" onclick="openPilotSlotSelector('suit')">
        <div class="slot-icon">ü•ã</div>
        <div class="slot-name">Suit</div>
        <div class="slot-item" id="slotSuit">Empty</div>
      </div>
      <div class="equip-slot pilot-slot" data-slot="gloves" onclick="openPilotSlotSelector('gloves')">
        <div class="slot-icon">üß§</div>
        <div class="slot-name">Gloves</div>
        <div class="slot-item" id="slotGloves">Empty</div>
      </div>
      <div class="equip-slot pilot-slot" data-slot="boots" onclick="openPilotSlotSelector('boots')">
        <div class="slot-icon">üë¢</div>
        <div class="slot-name">Boots</div>
        <div class="slot-item" id="slotBoots">Empty</div>
      </div>
      <div class="equip-slot pilot-slot" data-slot="implant1" onclick="openPilotSlotSelector('implant1')">
        <div class="slot-icon">üíâ</div>
        <div class="slot-name">Implant 1</div>
        <div class="slot-item" id="slotImplant1">Empty</div>
      </div>
      <div class="equip-slot pilot-slot" data-slot="implant2" onclick="openPilotSlotSelector('implant2')">
        <div class="slot-icon">üíâ</div>
        <div class="slot-name">Implant 2</div>
        <div class="slot-item" id="slotImplant2">Empty</div>
      </div>
      <div class="equip-slot pilot-slot" data-slot="trinket" onclick="openPilotSlotSelector('trinket')">
        <div class="slot-icon">üíé</div>
        <div class="slot-name">Trinket</div>
        <div class="slot-item" id="slotTrinket">Empty</div>
      </div>
      <div class="equip-stats-box" style="background:rgba(236,72,153,0.1);border:1px solid rgba(236,72,153,0.3);border-radius:10px;padding:10px;">
        <div style="font-size:10px;color:#888;margin-bottom:6px;">PILOT BONUSES</div>
        <div style="display:flex;justify-content:space-between;padding:3px 0;font-size:11px;"><span>üéØ CRIT</span><span id="pilotStatCrit" style="color:#EC4899;">+0%</span></div>
        <div style="display:flex;justify-content:space-between;padding:3px 0;font-size:11px;"><span>üçÄ LUCK</span><span id="pilotStatLuck" style="color:#EC4899;">+0%</span></div>
        <div style="display:flex;justify-content:space-between;padding:3px 0;font-size:11px;"><span>üí∞ SCRAP</span><span id="pilotStatScrap" style="color:#EC4899;">+0%</span></div>
      </div>
    </div>
  </div>
  
  <!-- Stash (Shared) -->
  <div style="margin-top:10px;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
      <span style="color:#00ff88;font-size:13px;">üì¶ STASH (<span id="stashCount">0</span> items)</span>
      <span style="color:#666;font-size:10px;">Click item to equip or sell</span>
    </div>
    <div id="equipmentStashGrid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(100px,1fr));gap:8px;max-height:160px;overflow-y:auto;padding:8px;background:rgba(0,0,0,0.3);border-radius:8px;border:1px solid rgba(139,92,246,0.2);">
      <div class="stash-empty" style="grid-column:1/-1;text-align:center;color:#555;padding:25px;font-size:11px;">No items yet. Keep loot from debrief screen!</div>
    </div>
  </div>
  
  <div class="menuBtns" style="margin-top:15px;">
    <button id="btnBackFromEquip">‚Üê BACK</button>
  </div>
</div>
</div>

<div id="highScoreScreen" class="screenOverlay">
<div class="screenBox">
<div class="screenTitle">TOP 10 PILOTS</div>
<p class="screenSub">Legends of the Galaxy</p>
<div id="highScoreList"></div>
<div class="menuBtns">
<button id="btnBackToStart">BACK</button>
<button id="btnStartFromHS">START</button>
</div>
</div>
</div>

<!-- V9: Vendor Shop Screen -->
<div id="vendorScreen" class="screenOverlay">
<div class="screenBox" style="max-width:900px;">
  <div class="screenTitle" style="font-size:28px;background:linear-gradient(90deg,#ffaa00,#ff6600);-webkit-background-clip:text;-webkit-text-fill-color:transparent;">ü™ô GALACTIC VENDOR</div>
  <p class="screenSub" style="color:#ffaa00;">Trade your scrap for powerful upgrades!</p>
  
  <!-- Scrap Display -->
  <div style="text-align:center;margin:15px 0;padding:12px;background:rgba(255,170,0,0.1);border:1px solid rgba(255,170,0,0.3);border-radius:10px;">
    <span style="font-size:14px;color:#888;">YOUR SCRAP:</span>
    <span id="vendorScrapDisplay" style="font-size:28px;color:#ffd700;font-weight:900;margin-left:15px;">0 üí∞</span>
  </div>
  
  <!-- Shop Categories Tabs -->
  <div style="display:flex;gap:5px;margin-bottom:15px;">
    <button class="vendor-tab active" data-tab="upgrades" onclick="showVendorTab('upgrades')" style="flex:1;padding:10px;background:rgba(139,92,246,0.2);border:1px solid #8B5CF6;border-radius:8px 8px 0 0;color:#8B5CF6;font-family:'Orbitron',monospace;font-size:11px;cursor:pointer;">‚öîÔ∏è UPGRADES</button>
    <button class="vendor-tab" data-tab="skins" onclick="showVendorTab('skins')" style="flex:1;padding:10px;background:rgba(255,170,0,0.1);border:1px solid rgba(255,170,0,0.3);border-radius:8px 8px 0 0;color:#aaa;font-family:'Orbitron',monospace;font-size:11px;cursor:pointer;">üé® SKINS</button>
    <button class="vendor-tab" data-tab="consumables" onclick="showVendorTab('consumables')" style="flex:1;padding:10px;background:rgba(0,255,136,0.1);border:1px solid rgba(0,255,136,0.3);border-radius:8px 8px 0 0;color:#aaa;font-family:'Orbitron',monospace;font-size:11px;cursor:pointer;">üß™ ITEMS</button>
  </div>
  
  <!-- Shop Items Grid -->
  <div id="vendorUpgradesTab" class="vendor-tab-content" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:12px;max-height:300px;overflow-y:auto;padding:5px;">
    <!-- Items populated by JS -->
  </div>
  <div id="vendorSkinsTab" class="vendor-tab-content" style="display:none;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:12px;max-height:300px;overflow-y:auto;padding:5px;">
    <!-- Skins populated by JS -->
  </div>
  <div id="vendorConsumablesTab" class="vendor-tab-content" style="display:none;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:12px;max-height:300px;overflow-y:auto;padding:5px;">
    <!-- Consumables populated by JS -->
  </div>
  
  <div class="menuBtns" style="margin-top:20px;">
    <button id="btnCloseVendor" onclick="closeVendorScreen()" style="border-color:#888;">‚Üê BACK</button>
  </div>
</div>
</div>

<div id="upgradeScreen" class="screenOverlay">
  <div class="screenBox upgradeBox" style="max-width:900px;">
    <div id="upgradeTitle" class="screenTitle" style="font-size:22px;background:linear-gradient(90deg,#f59e0b,#ec4899);-webkit-background-clip:text;-webkit-text-fill-color:transparent;text-shadow:none;">MISSION DEBRIEF</div>
    <p id="upgradeSub" class="screenSub" style="color:#aaa;">Recovered Alien Artifacts ‚Ä¢ Pick 1 upgrade</p>
    
    <!-- V9: Performance Grade Display -->
    <div id="debriefGradePanel" style="display:none;margin:10px 0;padding:12px;background:rgba(0,0,0,0.3);border-radius:10px;border:1px solid rgba(255,255,255,0.1);">
      <div style="display:flex;justify-content:space-around;align-items:center;">
        <div style="text-align:center;">
          <div id="debriefGrade" style="font-size:42px;font-weight:900;color:#f59e0b;">B</div>
          <div style="font-size:10px;color:#888;">GRADE</div>
        </div>
        <div style="text-align:center;">
          <div id="debriefScrap" style="font-size:24px;color:#ffd700;">+250 üí∞</div>
          <div style="font-size:10px;color:#888;">SCRAP EARNED</div>
        </div>
        <div style="text-align:center;">
          <div id="debriefTotalScrap" style="font-size:18px;color:#ffd700;">0 üí∞</div>
          <div style="font-size:10px;color:#888;">TOTAL</div>
        </div>
        <div style="text-align:center;">
          <div id="debriefKills" style="font-size:18px;color:#00ff88;">0</div>
          <div style="font-size:10px;color:#888;">KILLS</div>
        </div>
      </div>
    </div>
    
    <!-- V9: Collected Loot Panel -->
    <div id="collectedLootPanel" style="display:none;margin:15px 0;padding:12px;background:rgba(0,100,0,0.15);border-radius:10px;border:1px solid rgba(0,255,136,0.3);">
      <div style="font-size:12px;color:#00ff88;margin-bottom:10px;font-weight:700;">üì¶ COLLECTED LOOT</div>
      <div id="collectedLootGrid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:8px;max-height:150px;overflow-y:auto;"></div>
      <div id="noLootMessage" style="display:none;text-align:center;color:#666;padding:20px;">No loot collected this sector</div>
    </div>
    
    <!-- V9: Vendor Shop Panel -->
    <div id="vendorShopPanel" style="display:none;margin:15px 0;padding:12px;background:rgba(100,50,0,0.15);border-radius:10px;border:1px solid rgba(255,170,0,0.3);">
      <div style="font-size:12px;color:#ffaa00;margin-bottom:10px;font-weight:700;">ü™ô VENDOR SHOP</div>
      <div id="vendorShopGrid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:8px;max-height:200px;overflow-y:auto;"></div>
    </div>
    
    <div id="upgradeOptions" class="upgradeGrid"></div>
    <div class="menuBtns">
      <button id="btnUpgradeReroll" style="border-color:#00d4ff;">üé≤ REROLL (1)</button>
    </div>
  </div>
</div>

<div id="gameContainer">
<canvas id="backgroundCanvas"></canvas>
<canvas id="gameCanvas"></canvas>
<canvas id="fxCanvas"></canvas>
<canvas id="overlayCanvas"></canvas>

<div id="hud">
<div class="hud-left">
<span class="chip" id="hudScore">SCORE: 0</span>
<span class="chip" id="hudWave">WAVE: 1</span>
<button class="chip debug-chip" id="btnSkip19" title="DEBUG: Jump to Wave 19">SKIP‚Üê‚Äô19</button>
</div>
<div class="hud-right">
<div id="scrapDisplay"><span>üí∞</span><span id="hudScrap">0</span></div>
<span class="chip" id="hudStreak">STREAK: 0 <small>(+0%)</small></span>
<span id="livesWrap"></span>
</div>
</div>

<div id="xpBarContainer"><div id="xpBarFill"></div><span id="xpBarText">0 / 100 XP</span></div>
<div id="levelBadge">LVL 1</div>
<div id="toastContainer"></div>
<div id="multiplierBar"><div class="mult-label">x1.0</div><div class="mult-track"><div class="mult-fill" style="width:0%"></div></div></div>
<div id="nearMissIndicator"></div>
<div id="riskIndicator">DANGER +50%</div>
<div id="revengeBadge">REVENGE!</div>
<div id="missileIndicator">üöÄ CRUISE</div>
<div id="powerupBar"></div>
<div id="activeUpgradesPanel"></div>
<div id="waveAnnounce"></div>

<div id="overlay">
<div class="box">
<h2 id="overlayTitle">GAME OVER</h2>
<p>The galaxy remains in peril...</p>
<div class="stats">
<div class="stat"><div class="stat-value" id="finalScore">0</div><div class="stat-label">Score</div></div>
<div class="stat"><div class="stat-value" id="finalWave">1</div><div class="stat-label">Wave</div></div>
<div class="stat"><div class="stat-value" id="finalLevel">1</div><div class="stat-label">Level</div></div>
<div class="stat"><div class="stat-value" id="finalCombo">0</div><div class="stat-label">Max Combo</div></div>
<div class="stat"><div class="stat-value" id="finalNearMiss">0</div><div class="stat-label">Near Misses</div></div>
<div class="stat"><div class="stat-value" id="finalScrap" style="color:#ffd700">0</div><div class="stat-label">üí∞ Scrap</div></div>
<div class="stat"><div class="stat-value" id="finalLoot" style="color:#8B5CF6">0</div><div class="stat-label">Loot Drops</div></div>
</div>
<div id="nameEntry">
<h4>NEW HIGHSCORE! Enter your name:</h4>
<div id="nameInputDisplay">
<div class="name-char active" id="char0">A</div>
<div class="name-char" id="char1">A</div>
<div class="name-char" id="char2">A</div>
</div>
<div id="nameControls">
<button id="charUp">UP</button>
<button id="charDown">DN</button>
<button id="charNext">NEXT</button>
<button id="confirmName">OK</button>
</div>
</div>
<div id="highscoreSection">
<h3>TOP PILOTS</h3>
<div id="highscoreTable"></div>
</div>
<button id="restartBtn">RESTART</button>
<button id="exitBtn">EXIT</button>
<p class="kbd">or press <strong>SPACE</strong> / <strong>ENTER</strong></p>
</div>
</div>
</div>

<div id="controlArea">
<div id="joystickContainer">
<div class="joystick-base">
<div class="joystick-stick" id="joystickStick"></div>
</div>
</div>
<div id="fireButton">FIRE</div>
</div>

<script>
"use strict";

(function() {

try {

// ============================================================
// LOOT TABLES DATA (Embedded from loot-tables.json)
// ============================================================
var LOOT_DATA = {
  "metadata": { "version": "1.0.0", "description": "V9 Full Loot Integration" },
  "rarityConfig": {
    "NORMAL": { "color": "#9CA3AF", "glow": "#D1D5DB", "dropChance": 0.60, "scrapValue": 10 },
    "RARE": { "color": "#3B82F6", "glow": "#60A5FA", "dropChance": 0.20, "scrapValue": 25 },
    "EPIC": { "color": "#8B5CF6", "glow": "#A78BFA", "dropChance": 0.10, "scrapValue": 50 },
    "LEGENDARY": { "color": "#F59E0B", "glow": "#FBBF24", "dropChance": 0.08, "scrapValue": 100 },
    "MYTHIC": { "color": "#EC4899", "glow": "#F472B6", "dropChance": 0.02, "scrapValue": 250, "special": true }
  },
  "weaponUpgrades": {
    "temporary": [
      { "id": "temp_rapid_fire", "name": "Rapid Fire", "rarity": "NORMAL", "type": "temporary", "duration": 10000, "effects": { "fireRate": 1.3 }, "description": "+30% fire rate (10s)", "icon": "‚ö°" },
      { "id": "temp_damage", "name": "Damage Surge", "rarity": "RARE", "type": "temporary", "duration": 8000, "effects": { "damage": 2.0 }, "description": "2x damage (8s)", "icon": "üí•" },
      { "id": "temp_spread", "name": "Multi-Shot", "rarity": "EPIC", "type": "temporary", "duration": 12000, "effects": { "projectileCount": 3 }, "description": "3-way fire (12s)", "icon": "üéØ" }
    ],
    "runPersistent": [
      { "id": "run_damage", "name": "Plasma Capacitor", "rarity": "NORMAL", "type": "runPersistent", "maxStacks": 5, "effects": { "damage": 0.15 }, "description": "+15% damage", "icon": "üî•", "stackable": true },
      { "id": "run_firerate", "name": "Cooling Array", "rarity": "RARE", "type": "runPersistent", "maxStacks": 3, "effects": { "fireRate": 0.20 }, "description": "+20% fire rate", "icon": "‚ùÑÔ∏è", "stackable": true },
      { "id": "run_pierce", "name": "Penetrator Rounds", "rarity": "EPIC", "type": "runPersistent", "maxStacks": 1, "effects": { "pierce": 2 }, "description": "Pierce 2 enemies", "icon": "üéÜ", "stackable": false },
      { "id": "run_chain", "name": "Arc Conductor", "rarity": "LEGENDARY", "type": "runPersistent", "maxStacks": 1, "effects": { "chainCount": 3 }, "description": "Chain to 3 enemies", "icon": "‚ö°", "stackable": false }
    ],
    "permanent": [
      { "id": "perm_damage1", "name": "Hardened Rounds", "rarity": "EPIC", "type": "permanent", "tier": 1, "effects": { "baseDamage": 5 }, "description": "+5 base damage", "icon": "üõ°Ô∏è" },
      { "id": "perm_crit", "name": "Precision Optics", "rarity": "LEGENDARY", "type": "permanent", "tier": 1, "effects": { "critChance": 0.15 }, "description": "15% crit chance", "icon": "üéØ" },
      { "id": "bonzo_vaporizer", "name": "Bonzo's Vaporizer", "rarity": "MYTHIC", "type": "permanent", "tier": 1, "series": "bonzo", "effects": { "damage": 0.25, "fireRate": 0.15 }, "description": "Legendary Bonzo weapon", "icon": "üëΩ" }
    ]
  },
  "shipUpgrades": {
    "temporary": [
      { "id": "temp_shield", "name": "Energy Shield", "rarity": "NORMAL", "type": "temporary", "duration": 15000, "effects": { "shield": 50 }, "description": "+50 shield (15s)", "icon": "üõ°Ô∏è" },
      { "id": "temp_speed", "name": "Afterburner", "rarity": "RARE", "type": "temporary", "duration": 10000, "effects": { "speed": 1.5 }, "description": "+50% speed (10s)", "icon": "üöÄ" }
    ],
    "runPersistent": [
      { "id": "run_armor", "name": "Hull Reinforcement", "rarity": "NORMAL", "type": "runPersistent", "maxStacks": 10, "effects": { "maxHealth": 20 }, "description": "+20 health", "icon": "üí™", "stackable": true },
      { "id": "run_dodge", "name": "Phase Shifter", "rarity": "EPIC", "type": "runPersistent", "maxStacks": 1, "effects": { "dodgeChance": 0.10 }, "description": "10% dodge", "icon": "üëª", "stackable": false },
      { "id": "run_lifesteal", "name": "Nano Repair", "rarity": "LEGENDARY", "type": "runPersistent", "maxStacks": 1, "effects": { "lifesteal": 0.05 }, "description": "5% lifesteal", "icon": "‚ù§Ô∏è", "stackable": false }
    ],
    "permanent": [
      { "id": "perm_health1", "name": "Reinforced Hull", "rarity": "EPIC", "type": "permanent", "tier": 1, "effects": { "baseHealth": 50 }, "description": "+50 base health", "icon": "üõ°Ô∏è" },
      { "id": "bonzo_fortress", "name": "Bonzo's Fortress", "rarity": "MYTHIC", "type": "permanent", "tier": 1, "series": "bonzo", "effects": { "baseHealth": 100, "damageReduction": 0.10 }, "description": "+100 HP, 10% DR", "icon": "üëΩ" }
    ]
  },
  "specialCapsules": {
    "golden": { "spawnChance": 0.001, "minWave": 5, "maxPerSector": 2, "lootTable": { "EPIC": 0.6, "LEGENDARY": 0.4 } },
    "mythic": { "spawnChance": 0.003, "minWave": 10, "series": "bonzo" }
  },
  "visualUpgrades": {
    "shipSkins": [
      { "id": "skin_chrome", "name": "Chrome Finish", "rarity": "RARE", "sprite": "player/skin_chrome.png", "description": "Shiny chrome coating", "icon": "ü™û" },
      { "id": "skin_inferno", "name": "Inferno", "rarity": "EPIC", "sprite": "player/skin_inferno.png", "description": "Fire-themed hull", "icon": "üî•" },
      { "id": "skin_void", "name": "Void Walker", "rarity": "LEGENDARY", "sprite": "player/skin_void.png", "description": "Darkness incarnate", "icon": "üåë" },
      { "id": "skin_bonzo", "name": "Bonzo's Mark", "rarity": "MYTHIC", "series": "bonzo", "sprite": "player/skin_bonzo.png", "description": "Touched by the alien god", "icon": "üëΩ" }
    ],
    "trailEffects": [
      { "id": "trail_fire", "name": "Fire Trail", "rarity": "RARE", "color": "#ff6600", "description": "Leave flames behind", "icon": "üî•" },
      { "id": "trail_ice", "name": "Ice Trail", "rarity": "RARE", "color": "#00d4ff", "description": "Frozen path", "icon": "‚ùÑÔ∏è" },
      { "id": "trail_rainbow", "name": "Rainbow Trail", "rarity": "LEGENDARY", "color": "rainbow", "description": "Magnificent!", "icon": "üåà" }
    ]
  },
  "debriefRewards": {
    "waveCompletion": { "baseScrap": 50, "scrapPerWave": 10, "bossBonus": 200 },
    "performanceGrades": {
      "D": { "minScore": 0, "lootRolls": 1, "rarityBonus": 0, "scrapMultiplier": 0.5 },
      "C": { "minScore": 100, "lootRolls": 1, "rarityBonus": 0.05, "scrapMultiplier": 0.75 },
      "B": { "minScore": 300, "lootRolls": 2, "rarityBonus": 0.10, "scrapMultiplier": 1.0 },
      "A": { "minScore": 600, "lootRolls": 2, "rarityBonus": 0.15, "scrapMultiplier": 1.25 },
      "S": { "minScore": 1000, "lootRolls": 3, "rarityBonus": 0.25, "scrapMultiplier": 1.5 },
      "SS": { "minScore": 1500, "lootRolls": 4, "rarityBonus": 0.40, "scrapMultiplier": 2.0 }
    }
  }
};

// ============================================================
// LOOT SYSTEM - Core Drop & Rarity Calculation
// ============================================================
var LootSystem = (function() {
  var data = LOOT_DATA;
  var stats = { totalDrops: 0, dropsByRarity: { NORMAL: 0, RARE: 0, EPIC: 0, LEGENDARY: 0, MYTHIC: 0 }, capsulesFound: { golden: 0, mythic: 0 } };
  var capsuleTracker = { golden: {}, mythic: { totalKills: 0 } };

  function rollRarity(rarityBonus, forceMythic) {
    if (forceMythic) return 'MYTHIC';
    var config = data.rarityConfig;
    var roll = Math.random();
    rarityBonus = rarityBonus || 0;
    var adjusted = {
      MYTHIC: config.MYTHIC.dropChance + (rarityBonus * 0.5),
      LEGENDARY: config.LEGENDARY.dropChance + (rarityBonus * 0.3),
      EPIC: config.EPIC.dropChance + (rarityBonus * 0.2),
      RARE: config.RARE.dropChance,
      NORMAL: config.NORMAL.dropChance
    };
    var total = 0; for (var k in adjusted) total += adjusted[k];
    for (var k in adjusted) adjusted[k] /= total;
    var cumulative = 0;
    var rarities = ['MYTHIC', 'LEGENDARY', 'EPIC', 'RARE', 'NORMAL'];
    for (var i = 0; i < rarities.length; i++) {
      cumulative += adjusted[rarities[i]];
      if (roll <= cumulative) { stats.dropsByRarity[rarities[i]]++; return rarities[i]; }
    }
    return 'NORMAL';
  }

  function generateItem(category, rarity, filters) {
    var parts = category.split('.');
    var pool = data[parts[0]] && data[parts[0]][parts[1]];
    if (!pool || pool.length === 0) return null;
    var items = pool.slice();
    if (rarity) items = items.filter(function(item) { return item.rarity === rarity; });
    if (filters && filters.series) items = items.filter(function(item) { return item.series === filters.series; });
    if (items.length === 0) return null;
    var selected = items[Math.floor(Math.random() * items.length)];
    stats.totalDrops++;
    return {
      id: selected.id, name: selected.name, rarity: selected.rarity, type: selected.type,
      effects: selected.effects || {}, description: selected.description || '', icon: selected.icon || '‚≠ê',
      duration: selected.duration || 0, stackable: selected.stackable !== false, maxStacks: selected.maxStacks || 1,
      series: selected.series || null, instanceId: 'item_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
      timestamp: Date.now(), source: category
    };
  }

  function generateEnemyDrop(wave, enemyType) {
    // FIXED: Much lower drop rates to prevent spam
    // Base: 2% for normal enemies, 15% for bosses
    var baseDropChance = enemyType === 'boss' ? 0.15 : 0.02;
    // Scale slowly: +0.1% per wave, max +5%
    baseDropChance += Math.min(wave * 0.001, 0.05);
    
    if (Math.random() > baseDropChance) return null;
    
    // Track drops per wave to prevent spam
    if (!stats.dropsThisWave) stats.dropsThisWave = 0;
    if (stats.dropsThisWave >= 3 && enemyType !== 'boss') return null; // Max 3 drops per wave
    stats.dropsThisWave++;
    
    var rarityBonus = Math.min(wave * 0.001, 0.05);
    var rarity = rollRarity(rarityBonus, false);
    
    // Bosses always drop at least RARE
    if (enemyType === 'boss' && (rarity === 'NORMAL')) rarity = 'RARE';
    
    var isWeapon = Math.random() < 0.6;
    var category = isWeapon ? 'weaponUpgrades' : 'shipUpgrades';
    // Mostly temporary in early waves
    var subCategory = wave < 20 ? 'temporary' : (Math.random() < 0.7 ? 'temporary' : 'runPersistent');
    return generateItem(category + '.' + subCategory, rarity);
  }

  function shouldSpawnGoldenCapsule(wave, sector) {
    var config = data.specialCapsules.golden;
    if (wave < config.minWave) return false;
    var sectorKey = 'sector_' + sector;
    if (!capsuleTracker.golden[sectorKey]) capsuleTracker.golden[sectorKey] = 0;
    if (capsuleTracker.golden[sectorKey] >= config.maxPerSector) return false;
    // FIXED: Much rarer - 0.05% chance (1 in 2000 kills)
    if (Math.random() <= 0.0005) { capsuleTracker.golden[sectorKey]++; stats.capsulesFound.golden++; return true; }
    return false;
  }

  function shouldSpawnMythicCapsule(wave) {
    var config = data.specialCapsules.mythic;
    if (wave < config.minWave) return false;
    capsuleTracker.mythic.totalKills++;
    // FIXED: Super rare - 0.01% chance (1 in 10000 kills), minimum 500 kills between mythics
    if (capsuleTracker.mythic.totalKills < 500) return false;
    if (Math.random() <= 0.0001) { 
      stats.capsulesFound.mythic++; 
      capsuleTracker.mythic.totalKills = 0; // Reset counter
      return true; 
    }
    return false;
  }

  function generateGoldenCapsuleLoot() {
    var rarity = Math.random() < 0.6 ? 'EPIC' : 'LEGENDARY';
    return generateItem('shipUpgrades.permanent', rarity);
  }

  function generateMythicCapsuleLoot() {
    var categories = ['weaponUpgrades.permanent', 'shipUpgrades.permanent'];
    return generateItem(categories[Math.floor(Math.random() * categories.length)], 'MYTHIC', { series: 'bonzo' });
  }

  function calculatePerformanceGrade(waveStats) {
    var score = 0;
    score += (waveStats.kills || 0) * 2;
    score += ((waveStats.accuracy || 0) * 500);
    score += Math.max(0, 300 - (waveStats.time || 0));
    score += Math.max(0, 100 - (waveStats.damageTaken || 0)) * 2;
    var grades = data.debriefRewards.performanceGrades;
    var grade = 'D';
    for (var g in grades) { if (score >= grades[g].minScore) grade = g; }
    var gd = grades[grade];
    return { score: Math.floor(score), grade: grade, lootRolls: gd.lootRolls, rarityBonus: gd.rarityBonus, scrapMultiplier: gd.scrapMultiplier };
  }

  function generateDebriefRewards(waveStats, wave, isBossWave) {
    var perf = calculatePerformanceGrade(waveStats);
    var rewards = { items: [], scrap: 0, grade: perf.grade, score: perf.score };
    var baseScrap = data.debriefRewards.waveCompletion.baseScrap;
    var perWave = data.debriefRewards.waveCompletion.scrapPerWave;
    var bossBonus = isBossWave ? data.debriefRewards.waveCompletion.bossBonus : 0;
    rewards.scrap = Math.floor((baseScrap + (wave * perWave) + bossBonus) * perf.scrapMultiplier);
    for (var i = 0; i < perf.lootRolls; i++) {
      var rarity = rollRarity(perf.rarityBonus);
      var isPermanent = perf.grade === 'S' || perf.grade === 'SS' ? Math.random() < 0.4 : Math.random() < 0.15;
      var category = Math.random() < 0.5 ? 'weaponUpgrades' : 'shipUpgrades';
      var subCategory = isPermanent ? 'permanent' : 'runPersistent';
      var item = generateItem(category + '.' + subCategory, rarity);
      if (item) rewards.items.push(item);
    }
    return rewards;
  }

  function getRarityConfig(rarity) { return data.rarityConfig[rarity] || data.rarityConfig.NORMAL; }
  function resetStats() { 
    stats = { totalDrops: 0, dropsByRarity: { NORMAL: 0, RARE: 0, EPIC: 0, LEGENDARY: 0, MYTHIC: 0 }, capsulesFound: { golden: 0, mythic: 0 }, dropsThisWave: 0 }; 
    capsuleTracker = { golden: {}, mythic: { totalKills: 0 } }; 
  }
  
  function resetWaveDrops() { stats.dropsThisWave = 0; }

  return {
    rollRarity: rollRarity, generateItem: generateItem, generateEnemyDrop: generateEnemyDrop,
    shouldSpawnGoldenCapsule: shouldSpawnGoldenCapsule, shouldSpawnMythicCapsule: shouldSpawnMythicCapsule,
    generateGoldenCapsuleLoot: generateGoldenCapsuleLoot, generateMythicCapsuleLoot: generateMythicCapsuleLoot,
    calculatePerformanceGrade: calculatePerformanceGrade, generateDebriefRewards: generateDebriefRewards,
    getRarityConfig: getRarityConfig, getStats: function() { return stats; }, resetStats: resetStats, resetWaveDrops: resetWaveDrops, getData: function() { return data; }
  };
})();

// ============================================================
// UPGRADE MANAGER - Apply & Track Player Upgrades
// ============================================================
var V9UpgradeManager = (function() {
  var STORAGE_KEY = 'V9_PERMANENT_UPGRADES';
  var activeUpgrades = { temporary: [], runPersistent: [], permanent: [] };
  var upgradeStacks = {};
  var baseStats = { damage: 10, fireRate: 1.0, projectileSpeed: 5, projectileCount: 1, pierce: 0, critChance: 0, maxHealth: 100, speed: 3, dodgeChance: 0, damageReduction: 0, lifesteal: 0 };
  var finalStats = {};

  function recalculateStats() {
    finalStats = {}; for (var k in baseStats) finalStats[k] = baseStats[k];
    var additive = { damage: 0, maxHealth: 0, baseDamage: 0, baseHealth: 0 };
    var multipliers = { damage: 1.0, fireRate: 1.0, speed: 1.0, projectileSpeed: 1.0 };
    var absolute = { pierce: 0, projectileCount: 1, critChance: 0, dodgeChance: 0, damageReduction: 0, lifesteal: 0 };
    var allUpgrades = activeUpgrades.permanent.concat(activeUpgrades.runPersistent).concat(activeUpgrades.temporary);
    allUpgrades.forEach(function(upg) {
      if (!upg.effects) return;
      for (var stat in upg.effects) {
        var value = upg.effects[stat];
        if (stat === 'baseDamage' || stat === 'baseHealth') { additive[stat] = (additive[stat] || 0) + value; }
        else if (stat === 'damage' || stat === 'fireRate' || stat === 'speed' || stat === 'projectileSpeed') {
          if (typeof value === 'number' && value < 10) { multipliers[stat] *= (1 + value); }
          else { additive[stat] = (additive[stat] || 0) + value; }
        }
        else if (absolute[stat] !== undefined) { absolute[stat] = Math.max(absolute[stat], value); }
      }
    });
    finalStats.damage = (baseStats.damage + (additive.baseDamage || 0) + (additive.damage || 0)) * multipliers.damage;
    finalStats.maxHealth = baseStats.maxHealth + (additive.baseHealth || 0) + (additive.maxHealth || 0);
    finalStats.fireRate = baseStats.fireRate * multipliers.fireRate;
    finalStats.speed = baseStats.speed * multipliers.speed;
    finalStats.projectileSpeed = baseStats.projectileSpeed * multipliers.projectileSpeed;
    for (var a in absolute) { if (absolute[a] > 0) finalStats[a] = absolute[a]; }
  }

  function applyUpgrade(item) {
    if (!item || !item.type) return false;
    
    // Check stack limits for ALL types
    var currentStacks = upgradeStacks[item.id] || 0;
    var maxAllowed = item.maxStacks || 1;
    
    switch (item.type) {
      case 'temporary':
        // FIXED: Check if we already have this temporary buff active
        var hasActive = activeUpgrades.temporary.some(function(u) { return u.id === item.id; });
        if (hasActive && !item.stackable) return false; // Can't stack non-stackables
        if (currentStacks >= maxAllowed) return false;
        
        var upg = Object.assign({}, item, { appliedAt: Date.now(), expiresAt: Date.now() + (item.duration || 10000) });
        activeUpgrades.temporary.push(upg);
        upgradeStacks[item.id] = currentStacks + 1;
        setTimeout(function() { removeTemporaryUpgrade(upg.instanceId); }, item.duration || 10000);
        break;
      case 'runPersistent':
        if (currentStacks >= maxAllowed) return false;
        activeUpgrades.runPersistent.push(Object.assign({}, item, { appliedAt: Date.now() }));
        upgradeStacks[item.id] = currentStacks + 1;
        break;
      case 'permanent':
        if (hasPermanentUpgrade(item.id)) return false;
        activeUpgrades.permanent.push(Object.assign({}, item, { unlockedAt: Date.now() }));
        savePermanentUpgrades();
        break;
      default: return false;
    }
    recalculateStats(); updateActiveUpgradesUI();
    return true;
  }

  function removeTemporaryUpgrade(instanceId) {
    var idx = -1;
    var removedItem = null;
    for (var i = 0; i < activeUpgrades.temporary.length; i++) { 
      if (activeUpgrades.temporary[i].instanceId === instanceId) { 
        idx = i; 
        removedItem = activeUpgrades.temporary[i];
        break; 
      } 
    }
    if (idx !== -1) { 
      activeUpgrades.temporary.splice(idx, 1); 
      // FIXED: Decrement stack counter when temporary expires
      if (removedItem && removedItem.id) {
        upgradeStacks[removedItem.id] = Math.max(0, (upgradeStacks[removedItem.id] || 1) - 1);
      }
      recalculateStats(); 
      updateActiveUpgradesUI(); 
    }
  }

  function hasUpgrade(id) {
    return activeUpgrades.runPersistent.some(function(u) { return u.id === id; }) ||
           activeUpgrades.permanent.some(function(u) { return u.id === id; }) ||
           activeUpgrades.temporary.some(function(u) { return u.id === id; });
  }

  function hasPermanentUpgrade(id) { return activeUpgrades.permanent.some(function(u) { return u.id === id; }); }
  function getUpgradeStacks(id) { return upgradeStacks[id] || 0; }
  function getStat(name) { return finalStats[name] || baseStats[name] || 0; }
  function savePermanentUpgrades() { try { localStorage.setItem(STORAGE_KEY, JSON.stringify({ upgrades: activeUpgrades.permanent, savedAt: Date.now() })); } catch (e) {} }
  function loadPermanentUpgrades() { try { var saved = localStorage.getItem(STORAGE_KEY); if (saved) { var data = JSON.parse(saved); activeUpgrades.permanent = data.upgrades || []; recalculateStats(); return true; } } catch (e) {} return false; }
  function startNewRun() { activeUpgrades.temporary = []; activeUpgrades.runPersistent = []; upgradeStacks = {}; recalculateStats(); updateActiveUpgradesUI(); }
  function gameOver() { var lost = activeUpgrades.temporary.concat(activeUpgrades.runPersistent); activeUpgrades.temporary = []; activeUpgrades.runPersistent = []; upgradeStacks = {}; recalculateStats(); updateActiveUpgradesUI(); return lost; }
  function getAllUpgrades() { return { temporary: activeUpgrades.temporary.slice(), runPersistent: activeUpgrades.runPersistent.slice(), permanent: activeUpgrades.permanent.slice() }; }

  loadPermanentUpgrades(); recalculateStats();

  return {
    applyUpgrade: applyUpgrade, removeTemporaryUpgrade: removeTemporaryUpgrade, hasUpgrade: hasUpgrade,
    hasPermanentUpgrade: hasPermanentUpgrade, getUpgradeStacks: getUpgradeStacks, getStat: getStat, getAllUpgrades: getAllUpgrades,
    startNewRun: startNewRun, gameOver: gameOver, recalculateStats: recalculateStats, getBaseStats: function() { return baseStats; }, getFinalStats: function() { return finalStats; }
  };
})();

// ============================================================
// V9 LOOT INVENTORY SYSTEM (FIXED)
// Loot collected during waves, presented in debrief
// ============================================================
var lootInventory = [];       // Loot collected this sector (cleared after debrief)
var vendorStock = [];         // Current vendor offerings
var VENDOR_STOCK_SIZE = 6;    // How many items vendor sells

// Pricing by rarity
var LOOT_PRICES = {
  NORMAL: 50,
  RARE: 150,
  EPIC: 400,
  LEGENDARY: 1000,
  MYTHIC: 5000  // Not normally sold
};

function collectLootToInventory(item) {
  if (!item) return;
  lootInventory.push(item);
  console.log('[LOOT] Collected:', item.name, '(' + item.rarity + ')');
}

function showLootCollectedToast(item) {
  if (!item) return;
  var config = LootSystem.getRarityConfig(item.rarity);
  showToast('COLLECTED: ' + item.icon + ' ' + item.name, 'rarity-' + item.rarity.toLowerCase());
  beep(880, 0.05, 0.03);
}

function applyLootFromInventory(index) {
  if (index < 0 || index >= lootInventory.length) return false;
  var item = lootInventory[index];
  V9UpgradeManager.applyUpgrade(item);
  lootInventory.splice(index, 1);
  showToast('APPLIED: ' + item.name + '!', 'rarity-' + item.rarity.toLowerCase());
  beep(660, 0.08, 0.05);
  return true;
}

function sellLootFromInventory(index) {
  if (index < 0 || index >= lootInventory.length) return 0;
  var item = lootInventory[index];
  var price = Math.floor((LOOT_PRICES[item.rarity] || 50) * 0.5); // Sell for 50% of buy price
  lootInventory.splice(index, 1);
  addScrap(price);
  showToast('SOLD: +' + price + ' üí∞', 'gold');
  beep(440, 0.05, 0.03);
  return price;
}

function clearSectorLoot() {
  lootInventory = [];
}

function generateVendorStock(wave) {
  vendorStock = [];
  var sector = Math.floor((wave - 1) / 20) + 1;
  
  for (var i = 0; i < VENDOR_STOCK_SIZE; i++) {
    // Higher sectors get better vendor stock
    var rarityBonus = Math.min(sector * 0.05, 0.25);
    var rarity = LootSystem.rollRarity(rarityBonus, false);
    
    // Vendor never sells MYTHIC
    if (rarity === 'MYTHIC') rarity = 'LEGENDARY';
    
    var isWeapon = Math.random() < 0.5;
    var category = isWeapon ? 'weaponUpgrades' : 'shipUpgrades';
    var subCategory = Math.random() < 0.4 ? 'temporary' : 'runPersistent';
    
    var item = LootSystem.generateItem(category + '.' + subCategory, rarity, null);
    if (item) {
      item.price = LOOT_PRICES[item.rarity] || 100;
      vendorStock.push(item);
    }
  }
  return vendorStock;
}

function buyFromVendor(index) {
  if (index < 0 || index >= vendorStock.length) return false;
  var item = vendorStock[index];
  if (playerScrap < item.price) {
    showToast('NOT ENOUGH SCRAP!', 'red');
    beep(220, 0.1, 0.08);
    return false;
  }
  playerScrap -= item.price;
  updateScrapDisplay();
  V9UpgradeManager.applyUpgrade(item);
  vendorStock.splice(index, 1);
  showToast('BOUGHT: ' + item.name + '!', 'rarity-' + item.rarity.toLowerCase());
  beep(880, 0.08, 0.05);
  return true;
}

function getInventoryCount() {
  return lootInventory.length;
}

function getVendorStock() {
  return vendorStock.slice();
}

// ============================================================
// V9 DEBRIEF UI RENDERING
// ============================================================
function renderCollectedLoot() {
  var panel = document.getElementById('collectedLootPanel');
  var grid = document.getElementById('collectedLootGrid');
  var noLootMsg = document.getElementById('noLootMessage');
  
  if (!panel || !grid) return;
  
  if (lootInventory.length === 0) {
    grid.style.display = 'none';
    if (noLootMsg) noLootMsg.style.display = 'block';
    panel.style.display = 'block';
    return;
  }
  
  if (noLootMsg) noLootMsg.style.display = 'none';
  grid.style.display = 'grid';
  panel.style.display = 'block';
  
  grid.innerHTML = '';
  lootInventory.forEach(function(item, index) {
    var config = LootSystem.getRarityConfig(item.rarity);
    var sellPrice = Math.floor((LOOT_PRICES[item.rarity] || 50) * 0.5);
    
    var card = document.createElement('div');
    card.className = 'loot-inv-card rarity-' + item.rarity.toLowerCase();
    card.innerHTML = 
      '<span class="loot-icon">' + (item.icon || '‚≠ê') + '</span>' +
      '<div class="loot-info">' +
        '<div class="loot-name" style="color:' + config.color + '">' + item.name + '</div>' +
        '<div class="loot-desc">' + (item.description || '') + '</div>' +
      '</div>' +
      '<div class="loot-actions">' +
        '<button class="apply-btn" data-idx="' + index + '">APPLY</button>' +
        '<button class="keep-btn" data-idx="' + index + '" style="border-color:#8B5CF6;color:#8B5CF6;">KEEP</button>' +
        '<button class="sell-btn" data-idx="' + index + '">' + sellPrice + 'üí∞</button>' +
      '</div>';
    
    grid.appendChild(card);
  });
  
  // Attach event listeners
  grid.querySelectorAll('.apply-btn').forEach(function(btn) {
    btn.addEventListener('click', function(e) {
      e.stopPropagation();
      var idx = parseInt(this.getAttribute('data-idx'));
      applyLootFromInventory(idx);
      renderCollectedLoot(); // Re-render
      updateScrapDisplay();
    });
  });
  
  // KEEP button - add to equipment stash
  grid.querySelectorAll('.keep-btn').forEach(function(btn) {
    btn.addEventListener('click', function(e) {
      e.stopPropagation();
      var idx = parseInt(this.getAttribute('data-idx'));
      keepLootToStash(idx);
      renderCollectedLoot();
    });
  });
  
  grid.querySelectorAll('.sell-btn').forEach(function(btn) {
    btn.addEventListener('click', function(e) {
      e.stopPropagation();
      var idx = parseInt(this.getAttribute('data-idx'));
      sellLootFromInventory(idx);
      renderCollectedLoot(); // Re-render
      updateScrapDisplay();
    });
  });
}

// Keep loot item to equipment stash
function keepLootToStash(index) {
  if (index < 0 || index >= lootInventory.length) return;
  var item = lootInventory[index];
  lootInventory.splice(index, 1);
  addToStash(item);
}

function renderVendorShop() {
  var panel = document.getElementById('vendorShopPanel');
  var grid = document.getElementById('vendorShopGrid');
  
  if (!panel || !grid) return;
  
  if (vendorStock.length === 0) {
    panel.style.display = 'none';
    return;
  }
  
  panel.style.display = 'block';
  grid.innerHTML = '';
  
  vendorStock.forEach(function(item, index) {
    var config = LootSystem.getRarityConfig(item.rarity);
    var canAfford = playerScrap >= item.price;
    
    var card = document.createElement('div');
    card.className = 'loot-inv-card rarity-' + item.rarity.toLowerCase();
    card.innerHTML = 
      '<span class="loot-icon">' + (item.icon || '‚≠ê') + '</span>' +
      '<div class="loot-info">' +
        '<div class="loot-name" style="color:' + config.color + '">' + item.name + '</div>' +
        '<div class="loot-desc">' + (item.description || '') + '</div>' +
      '</div>' +
      '<div class="loot-actions">' +
        '<button class="buy-btn" data-idx="' + index + '" ' + (canAfford ? '' : 'disabled') + '>' + item.price + 'üí∞</button>' +
      '</div>';
    
    grid.appendChild(card);
  });
  
  // Attach event listeners
  grid.querySelectorAll('.buy-btn').forEach(function(btn) {
    btn.addEventListener('click', function(e) {
      e.stopPropagation();
      if (this.disabled) return;
      var idx = parseInt(this.getAttribute('data-idx'));
      buyFromVendor(idx);
      renderVendorShop(); // Re-render
      updateScrapDisplay();
    });
  });
}

function showDebriefGrade(gradeData) {
  var panel = document.getElementById('debriefGradePanel');
  var gradeEl = document.getElementById('debriefGrade');
  var scrapEl = document.getElementById('debriefScrap');
  var totalScrapEl = document.getElementById('debriefTotalScrap');
  var killsEl = document.getElementById('debriefKills');
  
  if (!panel) return;
  
  var gradeColors = { D: '#9CA3AF', C: '#60A5FA', B: '#8B5CF6', A: '#FBBF24', S: '#F59E0B', SS: '#EC4899' };
  
  if (gradeEl) {
    gradeEl.textContent = gradeData.grade;
    gradeEl.style.color = gradeColors[gradeData.grade] || '#fff';
  }
  if (scrapEl) scrapEl.textContent = '+' + gradeData.scrap + ' üí∞';
  if (totalScrapEl) totalScrapEl.textContent = playerScrap + ' üí∞';
  if (killsEl) killsEl.textContent = state.waveKills || 0;
  
  panel.style.display = 'block';
}

function hideDebriefPanels() {
  var panels = ['debriefGradePanel', 'collectedLootPanel', 'vendorShopPanel'];
  panels.forEach(function(id) {
    var el = document.getElementById(id);
    if (el) el.style.display = 'none';
  });
}

// ============================================================
// LOOT UI FUNCTIONS
// ============================================================
function updateActiveUpgradesUI() {
  var panel = document.getElementById('activeUpgradesPanel');
  if (!panel) return;
  var all = V9UpgradeManager.getAllUpgrades();
  var html = '';
  all.temporary.forEach(function(upg) {
    var remaining = Math.max(0, (upg.expiresAt - Date.now()) / 1000);
    var expiring = remaining < 3;
    var style = expiring ? 'animation:pulse 0.5s infinite;border-color:#ff4444;' : '';
    html += '<div class="upgrade-badge temporary" style="' + style + '"><span>' + (upg.icon || '‚è±Ô∏è') + '</span><span style="flex:1;font-size:8px">' + upg.name + '</span><span style="font-size:8px;' + (expiring ? 'color:#ff4444;font-weight:900' : '') + '">' + remaining.toFixed(0) + 's</span></div>';
  });
  var runUpgs = all.runPersistent.slice(0, 5);
  runUpgs.forEach(function(upg) {
    var stacks = V9UpgradeManager.getUpgradeStacks(upg.id);
    html += '<div class="upgrade-badge runPersistent"><span>' + (upg.icon || 'üîÑ') + '</span><span style="flex:1;font-size:8px">' + upg.name + (stacks > 1 ? ' x' + stacks : '') + '</span></div>';
  });
  panel.innerHTML = html;
}

function showLootDropNotification(item) {
  if (!item) return;
  var config = LootSystem.getRarityConfig(item.rarity);
  var div = document.createElement('div');
  div.className = 'loot-drop-notification';
  div.style.color = config.color;
  div.innerHTML = '<div class="rarity-label">' + item.rarity + ' DROP!</div><div class="item-icon">' + (item.icon || '‚≠ê') + '</div><div class="item-name">' + item.name + '</div><div class="item-desc">' + (item.description || '') + '</div>';
  document.body.appendChild(div);
  setTimeout(function() { if (div.parentNode) div.parentNode.removeChild(div); }, 2500);
  if (item.rarity === 'MYTHIC') { beep(440, 0.15, 0.1); beep(660, 0.15, 0.1); beep(880, 0.15, 0.1); }
  else if (item.rarity === 'LEGENDARY') { beep(660, 0.1, 0.08); beep(880, 0.1, 0.08); }
  else if (item.rarity === 'EPIC') { beep(550, 0.1, 0.06); }
}

function showCapsuleNotification(type, item, onClose) {
  var div = document.createElement('div');
  div.className = 'capsule-notification ' + type;
  var config = LootSystem.getRarityConfig(item.rarity);
  div.innerHTML = '<div style="font-size:48px;margin-bottom:20px">' + (type === 'mythic' ? 'üåå' : '‚ú®') + '</div>' +
    '<div style="font-size:14px;letter-spacing:3px;margin-bottom:10px;color:' + config.color + '">' + (type === 'mythic' ? 'MYTHIC CAPSULE!' : 'GOLDEN CAPSULE!') + '</div>' +
    '<div style="font-size:72px;margin:20px 0">' + (item.icon || '‚≠ê') + '</div>' +
    '<div style="font-size:24px;font-weight:900;color:' + config.color + '">' + item.name + '</div>' +
    '<div style="font-size:14px;opacity:0.8;margin-top:10px;max-width:300px">' + (item.description || '') + '</div>' +
    '<button style="margin-top:30px;padding:15px 40px;background:linear-gradient(135deg,' + config.color + ', ' + config.glow + ');border:none;border-radius:8px;font-family:Orbitron,monospace;font-size:14px;font-weight:700;color:#000;cursor:pointer">COLLECT</button>';
  document.body.appendChild(div);
  var btn = div.querySelector('button');
  btn.onclick = function() { if (div.parentNode) div.parentNode.removeChild(div); if (onClose) onClose(); };
  setTimeout(function() { if (div.parentNode) div.parentNode.removeChild(div); if (onClose) onClose(); }, 5000);
}

// Scrap tracking
var playerScrap = 0;
var totalScrapEarned = 0;

function addScrap(amount) {
  if (amount <= 0) return;
  playerScrap += amount;
  totalScrapEarned += amount;
  updateScrapDisplay();
  
  // Save total to localStorage for start screen
  try {
    var stored = parseInt(localStorage.getItem('V9_TOTAL_SCRAP') || '0');
    localStorage.setItem('V9_TOTAL_SCRAP', String(stored + amount));
  } catch(e) {}
}

function updateScrapDisplay() {
  var el = document.getElementById('hudScrap');
  if (el) el.textContent = playerScrap.toLocaleString();
}

// ============================================================
// END LOOT SYSTEM INTEGRATION
// ============================================================

var setVh = function() { document.documentElement.style.setProperty("--vh", (window.innerHeight * 0.01) + "px"); };
setVh();
window.addEventListener("resize", setVh);

// ============================================================
// CANVAS & CONTEXTS
// ============================================================
var bg = document.getElementById("backgroundCanvas");
var canvas = document.getElementById("gameCanvas");
var fxCanvas = document.getElementById("fxCanvas");
var overlayCanvas = document.getElementById("overlayCanvas");
var bctx = bg.getContext("2d");
var ctx = canvas.getContext("2d");
var fxctx = fxCanvas.getContext("2d");
var octx = overlayCanvas.getContext("2d");


// ============================================================
// SPRITE SYSTEM (optional, with safe fallback)
// ============================================================
var SPR = { ready: false, img: {}, missing: [] };

// Central, adjustable base path (keep relative to this HTML file)
var ASSET_BASE = "./assets/sprites/";
// Visual scaling: keep hitbox small, draw sprite larger (prevents ‚Äútiny ship‚Äù)
var PLAYER_SPRITE_SCALE = 3.0; // visual scale only (hitbox unchanged)
var PLAYER_SPRITE_Y_OFFSET = -6; // negative = move sprite up (prevents tail clipping)   // 32px hitbox -> ~144px sprite width
var ENEMY_SPRITE_SCALE  = 2.4;   // optional, used if enemy sprites appear too small


// Sprite manifest = ONLY place you need to touch for new visuals.
// Missing files are tolerated: the game will fall back to canvas-vector rendering.
var SPRITE_MANIFEST = {
  player: {
    normal: "player/ship_normal.png",
    missile: "player/ship_missile.png",     // early cruise-missile unlock look (rename here if needed)
    laser: "player/ship_laser.png",
    kaboom: "player/ship_kaboom.png",
    dual: "player/ship_dualshot.png"
  },
  enemy: {
    // minimal set used by current V8 spawns
    normal: "enemies/enemy_normal.png",
    drone: "enemies/enemy_elite.png",       // default mapping for V8 "drone" type (swap if you have a dedicated file)

    // extended set (as provided from your sprite tool) ‚Äî safe even if unused
    tough: "enemies/enemy_tough.png",
    tank: "enemies/enemy_tank.png",
    diver: "enemies/enemy_diver.png",
    sniper: "enemies/enemy_sniper.png",
    bomber: "enemies/enemy_bomber.png",
    shield: "enemies/enemy_shield.png",
    zigzag: "enemies/enemy_zigzag.png",
    elite: "enemies/enemy_elite.png"
  },
  boss: {
    boss1: "boss/boss_1.png",
    boss2: "boss/boss_2.png",
    boss3: "boss/boss_3.png",
    final: "boss/boss_final.png",
    mega: "boss/boss_mega.png"
  }
};

// Optional extension hook: registerSprite("enemy.myNewType", "enemies/enemy_myNewType.png")
function registerSprite(dotKey, relativePath) {
  try {
    var parts = String(dotKey || "").split(".");
    if (parts.length !== 2) return false;
    var group = parts[0], key = parts[1];
    if (!SPRITE_MANIFEST[group]) SPRITE_MANIFEST[group] = {};
    SPRITE_MANIFEST[group][key] = String(relativePath || "");
    return true;
  } catch (e) { return false; }
}

function preloadSprites(onDone) {
  try {
    var entries = [];
    for (var group in SPRITE_MANIFEST) {
      for (var key in SPRITE_MANIFEST[group]) {
        entries.push([group + "." + key, ASSET_BASE + SPRITE_MANIFEST[group][key]]);
      }
    }

    var pending = entries.length;
    if (!pending) {
      SPR.ready = true;
      if (onDone) onDone();
      return;
    }

    entries.forEach(function(ent) {
      var k = ent[0], src = ent[1];
      var im = new Image();

      im.onload = function() {
        SPR.img[k] = im;
        pending--;
        if (pending <= 0) {
          SPR.ready = true;
          try {
            if (SPR.missing && SPR.missing.length) {
              console.warn("Sprite preload: missing/failed files (" + SPR.missing.length + "):", SPR.missing.slice(0, 25));
            }
          } catch (e) {}
          if (onDone) onDone();
        }
      };

      im.onerror = function() {
        // Intentionally swallow errors: missing files must never crash the game.
        // We only track them for diagnostics (console), gameplay always falls back safely.
        try { SPR.missing.push(k + " ‚Üê " + src); } catch (e) {}
        pending--;
        if (pending <= 0) {
          SPR.ready = true;
          try {
            if (SPR.missing && SPR.missing.length) {
              console.warn("Sprite preload: missing/failed files (" + SPR.missing.length + "):", SPR.missing.slice(0, 25));
            }
          } catch (e) {}
          if (onDone) onDone();
        }
      };

      im.src = src;
    });
  } catch (e) {
    console.warn("preloadSprites failed:", e);
    SPR.ready = true;
    if (onDone) onDone();
  }
}

function getSprite(key) {
  var im = SPR.img[key];
  return (im && im.naturalWidth) ? im : null;
}

function choosePlayerSpriteKey() {
  // Visual priority: active/persistent weapon upgrades override missile look.
  // Note: In this V8 build, LASER/DUALSHOT/KABOOM are persistentUpgrades (not activePowerups),
  // so we must check both to avoid missile visual dominating.
  try {
    if (typeof permanentUpgrades !== "undefined") {
      if (permanentUpgrades.kaboom) return "player.kaboom";
      if (permanentUpgrades.laser) return "player.laser";
      if (permanentUpgrades.dualshot) return "player.dual";
    }
  } catch (e) {}

  if (typeof hasPowerup === "function") {
    if (hasPowerup("KABOOM")) return "player.kaboom";
    if (hasPowerup("LASER")) return "player.laser";
    if (hasPowerup("DUALSHOT")) return "player.dual";
  }

  // Missile look only when unlocked AND no other weapon upgrade is active.
  try {
    if (typeof state !== "undefined" && typeof CONFIG !== "undefined") {
      if (state.level >= CONFIG.MISSILE_UNLOCK_LEVEL) return "player.missile";
    }
  } catch (e) {}

  return "player.normal";
}

function chooseBossSpriteKey(bossPhase) {
  bossPhase = bossPhase || 1;
  if (bossPhase >= 5) return "boss.mega";
  if (bossPhase >= 4) return "boss.final";
  if (bossPhase === 3) return "boss.boss3";
  if (bossPhase === 2) return "boss.boss2";
  return "boss.boss1";
}

function chooseEnemySpriteKey(type) {
  if (type === "boss") return null; // handled separately

  // Current V8 types
  if (type === "drone") return "enemy.drone";
  if (type === "normal") return "enemy.normal";

  // Extended types (safe even if unused today)
  if (type === "tough") return "enemy.tough";
  if (type === "tank") return "enemy.tank";
  if (type === "diver") return "enemy.diver";
  if (type === "sniper") return "enemy.sniper";
  if (type === "bomber") return "enemy.bomber";
  if (type === "shield") return "enemy.shield";
  if (type === "zigzag") return "enemy.zigzag";
  if (type === "elite") return "enemy.elite";

  // Unknown type ‚Üê‚Äô fall back to normal visuals
  return "enemy.normal";
}

function tryDrawPlayerSprite(x, y, w, h, bankAngle) {
  var key = choosePlayerSpriteKey();
  var im = getSprite(key);
  if (!im) return false;

  // Draw bigger than hitbox (visual scale) while keeping collisions stable.
  var drawW = Math.max(w, w * (PLAYER_SPRITE_SCALE || 1));
  var aspect = (im.naturalHeight || im.height) / (im.naturalWidth || im.width);
  var drawH = Math.max(h, drawW * aspect);

  // Center the visual sprite on the hitbox.
  var dx = x + (w - drawW) / 2;
  // Bottom-align the sprite to the hitbox to avoid tail clipping at screen edge.
  var dy = y + h - drawH + (PLAYER_SPRITE_Y_OFFSET || 0);

  ctx.save();
  try {
    var cx = x + w / 2, cy = y + h / 2;
    ctx.translate(cx, cy);
    ctx.rotate((bankAngle || 0) * 0.22);
    ctx.translate(-cx, -cy);

    // subtle glow - optional visual polish
    ctx.shadowColor = "rgba(0,255,220,0.35)";
    ctx.shadowBlur = 10;

    ctx.drawImage(im, dx, dy, drawW, drawH);
  } finally {
    ctx.restore();
  }
  return true;
}

// Start loading immediately. Game runs even if assets are missing.
preloadSprites();


// ============================================================
// UI ELEMENTS
// ============================================================
var hudScore = document.getElementById("hudScore");
var hudWave = document.getElementById("hudWave");
var hudStreak = document.getElementById("hudStreak");
var livesWrap = document.getElementById("livesWrap");
var overlay = document.getElementById("overlay");
var overlayTitle = document.getElementById("overlayTitle");
var restartBtn = document.getElementById("restartBtn");
var exitBtn = document.getElementById("exitBtn");

var btnSkip19 = document.getElementById("btnSkip19");
if (btnSkip19) {
  btnSkip19.addEventListener("click", function(ev){
    ev.preventDefault();
    debugJumpToWave(19);
  });
}

/**
 * DEBUG helper: jump directly into a given wave (no debrief), to speed up testing.
 * This is intentionally conservative: it clears active entities and forces a clean wave spawn.
 */
function debugJumpToWave(targetWave){
  try {
    // Hard-close any modal/debrief state
    debriefActive = false;
    debriefQueue = [];
    pendingMilestones = [];
    currentUpgradeContext = null;
    upgradeModalOpen = false;
    if (typeof upgradeScreen !== "undefined" && upgradeScreen) upgradeScreen.classList.remove("active");
    if (typeof overlay !== "undefined" && overlay) overlay.style.display = "none";

    // Clear entities/projectiles/drops
    enemies = [];
    playerBullets = [];
    enemyBullets = [];
    cruiseMissiles = [];
    shockwaves = [];
    powerupDrops = [];

    // Reset wave state
    state.wave = targetWave;
    state.perfectWave = true;
    state.waveTransitioning = false;
    if (typeof hudWave !== "undefined" && hudWave) hudWave.textContent = "WAVE: " + state.wave;

    // Spawn enemies for the target wave
    if (state.wave % 5 === 0) {
      createBoss();
    } else {
      createWaveEnemies();
    }

    // Resume loop
    lastT = performance.now();
    state.running = true;
    requestAnimationFrame(loop);
  } catch (e) {
    console.error("debugJumpToWave failed:", e);
  }
}

var startScreen = document.getElementById("startScreen");
var highScoreScreen = document.getElementById("highScoreScreen");
var startHighscoreTable = document.getElementById("startHighscoreTable");
var highScoreList = document.getElementById("highScoreList");
var btnStart = document.getElementById("btnStart");
var btnOpenHighscores = document.getElementById("btnOpenHighscores");
var btnBackToStart = document.getElementById("btnBackToStart");
var btnStartFromHS = document.getElementById("btnStartFromHS");
var upgradeScreen = document.getElementById("upgradeScreen");
var upgradeOptions = document.getElementById("upgradeOptions");
var upgradeSub = document.getElementById("upgradeSub");
var upgradeTitle = upgradeScreen.querySelector('.screenTitle');
var btnUpgradeReroll = document.getElementById("btnUpgradeReroll");

var controlArea = document.getElementById("controlArea");
var powerupBar = document.getElementById("powerupBar");
var waveAnnounce = document.getElementById("waveAnnounce");
var nameEntry = document.getElementById("nameEntry");
var highscoreTable = document.getElementById("highscoreTable");
var finalScore = document.getElementById("finalScore");
var finalWave = document.getElementById("finalWave");
var finalCombo = document.getElementById("finalCombo");
var finalLevel = document.getElementById("finalLevel");
var finalNearMiss = document.getElementById("finalNearMiss");
var toastContainer = document.getElementById("toastContainer");
var multiplierBar = document.getElementById("multiplierBar");
var nearMissIndicator = document.getElementById("nearMissIndicator");
var riskIndicator = document.getElementById("riskIndicator");
var revengeBadge = document.getElementById("revengeBadge");
var xpBarFill = document.getElementById("xpBarFill");
var xpBarText = document.getElementById("xpBarText");
var levelBadge = document.getElementById("levelBadge");
var missileIndicator = document.getElementById("missileIndicator");

// ============================================================
// HELPERS
// ============================================================
function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
function rand(a, b) { return a + Math.random() * (b - a); }
function randInt(a, b) { return Math.floor(rand(a, b + 1)); }
function randChoice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
function lerp(a, b, t) { return a + (b - a) * t; }
function rectsOverlap(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
function dist(x1, y1, x2, y2) { return Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)); }

// ============================================================
// GAME STATE & CONFIG
// ============================================================
var CONFIG = {
  PLAYER_DAMAGE_BASE_MULTIPLIER: 0.88,
  HERO_DAMAGE: 50,
  CRIT_CHANCE: 0.15,
  CRIT_MULTIPLIER: 2.5,
  MAX_ENEMY_BULLETS: 12,
  BOSS_HP_MULTIPLIER: 2.5,
  ENEMY_HP_GLOBAL_MULTIPLIER: 1.2,
  MILESTONE_INTERVAL: 20,
  DEBRIEF_WAVE_INTERVAL: 20,
  DEBRIEF_MAX_PICKS: 3,
  PARTICLE_LIMIT: 350,
  TRAIL_LIMIT: 180,
  NORMAL_DROP_CHANCE: 0.065,
  BOSS_WEAPON_CHANCE: 1.0,
  
  // ADDICTION MECHANICS
  NEAR_MISS_DISTANCE: 35,
  NEAR_MISS_POINTS: 25,
  NEAR_MISS_MULT_BOOST: 0.05,
  RISK_ZONE_THRESHOLD: 0.35,
  RISK_ZONE_BONUS: 1.5,
  PERFECT_WAVE_BONUS: 500,
  REVENGE_DURATION: 5,
  REVENGE_DAMAGE_MULT: 2.0,
  MILESTONES: [5000, 10000, 25000, 50000, 100000, 250000, 500000],
  
  // XP SYSTEM
  BASE_XP_PER_LEVEL: 100,
  XP_SCALING: 1.03,
  XP_PER_KILL_BASE: 10,
  XP_PER_BOSS_KILL: 150,
  
  // CRUISE MISSILES (Level unlocks)
  MISSILE_UNLOCK_LEVEL: 10,
  MISSILE_DUAL_LEVEL: 30,
  MISSILE_BASE_INTERVAL: 1.0,
  MISSILE_BASE_DAMAGE: 80,
  MISSILE_SPLASH_RADIUS: 70,
  
  // V9 LOOT SYSTEM
  SCRAP_PER_ENEMY: 5,
  SCRAP_PER_BOSS: 100,
  SCRAP_PER_WAVE_BONUS: 25
};

var state = {
  running: false,
  score: 0,
  wave: 1,
  lives: 3,
  invulnT: 0,
  keys: {},
  touch: { dir: 0, firing: false },
  screenShake: 0,
  chromatic: 0,
  combo: 0,
  comboTimer: 0,
  maxCombo: 0,
  slowMo: 0,
  flashAlpha: 0,
  waveTransitioning: false,
  
  // Addiction state
  nearMissCount: 0,
  nearMissCooldown: 0,
  multiplier: 1.0,
  multiplierDecay: 0,
  perfectWave: true,
  revengeTimer: 0,
  inRiskZone: false,
  lastMilestone: 0,
  totalNearMisses: 0,
  
  // XP System state
  level: 1,
  xp: 0,
  xpToNextLevel: 100,
  totalXpEarned: 0,
  missileTimer: 0,
  missilesActive: false,
  
  // V9 Wave Stats Tracking (for performance grading)
  waveKills: 0,
  waveAccuracy: 0,
  waveTime: 0,
  waveDamageTaken: 0,
  waveShotsFired: 0,
  waveShotsHit: 0,
  waveStartTime: 0
};

var gameStarted = false;
var cruiseMissiles = [];

var streak = { hits: 0, bonusPct: 0 };
function getStreakFactor() { return 1 + streak.bonusPct / 100; }

function recalcStreakBonus() {
  var h = streak.hits;
  var pct = h <= 0 ? 0 : h <= 10 ? h * 2 : 20 + (h - 10) * 4;
  streak.bonusPct = Math.min(60, pct);
}

// ============================================================
// XP SYSTEM
// ============================================================
function calculateXpForLevel(level) {
  return Math.floor(CONFIG.BASE_XP_PER_LEVEL * Math.pow(CONFIG.XP_SCALING, level - 1));
}

function gainXP(amount) {
  var xpMult = state.multiplier >= 5.0 ? 2 : 1; // Double XP at high multiplier
  var xpBonus = 1 + (getShipUpgLevel("xp") * 0.10);
  var finalXP = Math.floor(amount * xpMult * xpBonus);
  state.xp += finalXP;
  state.totalXpEarned += finalXP;
  
  while (state.xp >= state.xpToNextLevel) {
    state.xp -= state.xpToNextLevel;
    state.level += 1;
    state.xpToNextLevel = calculateXpForLevel(state.level);
    onLevelUp();
    milestoneMaybeOffer(state.level);
  }
  updateXPBar();
}

function onLevelUp() {
  showToast("LEVEL " + state.level + "!", "levelup");
  levelBadge.classList.add("levelup");
  setTimeout(function() { levelBadge.classList.remove("levelup"); }, 1000);
  state.screenShake = 12;
  state.flashAlpha = 0.3;
  beep(440, 0.1, 0.08);
  beep(660, 0.1, 0.08);
  beep(880, 0.15, 0.1);
  spawnFirework(canvas.width / 2, canvas.height / 3, ["#00ffcc", "#ffd700", "#ff00ff"]);
  
  // Level unlock messages
  if (state.level === CONFIG.MISSILE_UNLOCK_LEVEL) {
    showToast("üöÄ CRUISE MISSILE UNLOCKED!", "gold");
    state.missilesActive = true;
    missileIndicator.classList.add("active");
  }
  if (state.level === CONFIG.MISSILE_DUAL_LEVEL) {
    showToast("üöÄüöÄ DUAL MISSILES!", "gold");
  }
  updateMissileIndicator();
}

function updateXPBar() {
  var pct = (state.xp / state.xpToNextLevel) * 100;
  xpBarFill.style.width = pct + "%";
  xpBarText.textContent = state.xp + " / " + state.xpToNextLevel + " XP";
  levelBadge.textContent = "LVL " + state.level;
}

function getMissileDamage() {
  var base = CONFIG.MISSILE_BASE_DAMAGE + (state.level - CONFIG.MISSILE_UNLOCK_LEVEL) * 8;
  base *= (1 + getShipUpgLevel("msd") * 0.12);
  base *= CONFIG.PLAYER_DAMAGE_BASE_MULTIPLIER;
  return Math.floor(base);
}

function getMissileInterval() {
  var base = CONFIG.MISSILE_BASE_INTERVAL;

  // Level-based ramp
  var lvlAdj = base;
  if (state.level >= 30) lvlAdj = base * 0.5;
  else if (state.level >= 20) {
    var progress = (state.level - 20) / 10;
    lvlAdj = base * (0.9 - progress * 0.4);
  }

  // Persistent ship upgrade: missile interval reduction
  var upg = 1 - (getShipUpgLevel("msi") * 0.06);
  upg = Math.max(0.55, upg);
  return lvlAdj * upg;
}

function getMissileCount() {
  return state.level >= CONFIG.MISSILE_DUAL_LEVEL ? 2 : 1;
}

function updateMissileIndicator() {
  if (state.level >= CONFIG.MISSILE_UNLOCK_LEVEL) {
    missileIndicator.classList.add("active");
    var count = getMissileCount();
    var interval = getMissileInterval().toFixed(2);
    missileIndicator.textContent = (count > 1 ? "üöÄüöÄ" : "üöÄ") + " " + interval + "s";
  } else {
    missileIndicator.classList.remove("active");
  }
}

// ============================================================
// CRUISE MISSILE SYSTEM
// ============================================================
function updateCruiseMissiles(dt) {
  if (state.level < CONFIG.MISSILE_UNLOCK_LEVEL) return;
  
  // Missiles now fire with player fire command - cooldown managed separately
  state.missileTimer = Math.max(0, state.missileTimer - dt);
  
  for (var i = cruiseMissiles.length - 1; i >= 0; i--) {
    var m = cruiseMissiles[i];
    if (m.target && m.target.alive) {
      var tx = m.target.x + m.target.w / 2;
      var ty = m.target.y + m.target.h / 2;
      var dx = tx - m.x;
      var dy = ty - m.y;
      var d = Math.sqrt(dx * dx + dy * dy);
      if (d > 0) {
        m.speed = Math.min(m.speed + 800 * dt, 1200);
        var targetAngle = Math.atan2(dy, dx);
        var angleDiff = targetAngle - m.angle;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        m.angle += angleDiff * 8 * dt;
        m.vx = Math.cos(m.angle) * m.speed;
        m.vy = Math.sin(m.angle) * m.speed;
      }
    } else {
      m.target = findClosestEnemy(m.x, m.y);
      if (!m.target) {
        m.vy = -m.speed;
        m.speed = Math.min(m.speed + 500 * dt, 800);
      }
    }
    
    m.x += m.vx * dt;
    m.y += m.vy * dt;
    addTrail(m.x, m.y, "#ff6600", 5);
    
    var hit = false;
    for (var j = 0; j < enemies.length; j++) {
      var e = enemies[j];
      if (!e.alive) continue;
      var ex = e.x + e.w / 2;
      var ey = e.y + e.h / 2;
      var hitDist = dist(m.x, m.y, ex, ey);
      if (hitDist < e.w / 2 + 10) {
        missileSplashDamage(m.x, m.y);
        hit = true;
        break;
      }
    }
    
    if (hit || m.y < -50 || m.y > canvas.height + 50 || m.x < -50 || m.x > canvas.width + 50) {
      cruiseMissiles.splice(i, 1);
    }
  }
}

function fireCruiseMissile() {
  var count = getMissileCount();
  var target = findClosestEnemy(player.x + player.w / 2, player.y);
  
  if (count === 1) {
    cruiseMissiles.push({
      x: player.x + player.w / 2,
      y: player.y,
      vx: 0, vy: -100,
      speed: 100,
      angle: -Math.PI / 2,
      target: target,
      damage: getMissileDamage()
    });
  } else {
    var offsets = [-player.w / 2 - 5, player.w / 2 + 5];
    for (var i = 0; i < 2; i++) {
      cruiseMissiles.push({
        x: player.x + player.w / 2 + offsets[i],
        y: player.y + player.h / 2,
        vx: offsets[i] * 0.5,
        vy: -80,
        speed: 80,
        angle: -Math.PI / 2,
        target: target,
        damage: getMissileDamage()
      });
    }
  }
  beep(150, 0.05, 0.03);
}

function findClosestEnemy(x, y) {
  var closest = null;
  var closestDist = Infinity;
  for (var i = 0; i < enemies.length; i++) {
    var e = enemies[i];
    if (!e.alive) continue;
    var ex = e.x + e.w / 2;
    var ey = e.y + e.h / 2;
    var d = dist(x, y, ex, ey);
    if (d < closestDist) {
      closestDist = d;
      closest = e;
    }
  }
  return closest;
}

function missileSplashDamage(x, y) {
  var damage = getMissileDamage();
  var radius = CONFIG.MISSILE_SPLASH_RADIUS;
  spawnMegaExplosion(x, y, "normal");
  beep(180, 0.1, 0.08);
  state.screenShake = 6;
  
  for (var i = 0; i < enemies.length; i++) {
    var e = enemies[i];
    if (!e.alive) continue;
    var ex = e.x + e.w / 2;
    var ey = e.y + e.h / 2;
    var d = dist(x, y, ex, ey);
    if (d < radius) {
      var falloff = 1 - (d / radius) * 0.5;
      var finalDamage = Math.floor(damage * falloff);
      e.hp -= finalDamage;
      addFloatText(ex, ey, "-" + finalDamage, "damage");
      spawnParticles(ex, ey, "#ff6600", 8, 0.8);
      if (e.hp <= 0) {
        e.alive = false;
        onEnemyKilled(e, ex, ey);
        var pts = e.type === "boss" ? 500 : e.type === "tank" ? 40 : 20;
        state.score += pts;
        gainXP(e.type === "boss" ? CONFIG.XP_PER_BOSS_KILL : CONFIG.XP_PER_KILL_BASE);
        registerHit();
        spawnMegaExplosion(ex, ey, e.type === "boss" ? "boss" : "normal");
        explosionSound();
        if (e.type === "boss") spawnBossDrop(ex, ey);
      }
    }
  }
}

function drawCruiseMissiles() {
  for (var i = 0; i < cruiseMissiles.length; i++) {
    var m = cruiseMissiles[i];
    ctx.save();
    ctx.translate(m.x, m.y);
    ctx.rotate(m.angle + Math.PI / 2);
    
    var grad = ctx.createLinearGradient(0, -12, 0, 12);
    grad.addColorStop(0, "#ffffff");
    grad.addColorStop(0.3, "#ff8800");
    grad.addColorStop(0.6, "#ff4400");
    grad.addColorStop(1, "#ff6600");
    ctx.fillStyle = grad;
    ctx.shadowColor = "#ff6600";
    ctx.shadowBlur = 15;
    
    ctx.beginPath();
    ctx.moveTo(0, -12);
    ctx.lineTo(-4, -4);
    ctx.lineTo(-4, 8);
    ctx.lineTo(4, 8);
    ctx.lineTo(4, -4);
    ctx.closePath();
    ctx.fill();
    
    // Fins
    ctx.fillStyle = "#ff4400";
    ctx.beginPath();
    ctx.moveTo(-4, 6);
    ctx.lineTo(-8, 12);
    ctx.lineTo(-4, 10);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(4, 6);
    ctx.lineTo(8, 12);
    ctx.lineTo(4, 10);
    ctx.closePath();
    ctx.fill();
    
    // Flame
    var flameSize = 5 + Math.sin(gameTime * 30) * 3;
    var flameGrad = ctx.createLinearGradient(0, 8, 0, 8 + flameSize);
    flameGrad.addColorStop(0, "#ffffff");
    flameGrad.addColorStop(0.3, "#ffff00");
    flameGrad.addColorStop(0.6, "#ff6600");
    flameGrad.addColorStop(1, "rgba(255,100,0,0)");
    ctx.fillStyle = flameGrad;
    ctx.beginPath();
    ctx.moveTo(-3, 8);
    ctx.lineTo(0, 8 + flameSize);
    ctx.lineTo(3, 8);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
  }
}

// ============================================================
// MINI TOAST SYSTEM - Non-intrusive notifications
// ============================================================
function showToast(text, colorClass, customStyle) {
  var toast = document.createElement("div");
  toast.className = "mini-toast " + (colorClass || "");
  toast.textContent = text;
  
  // V9: Support custom inline styles for rarity colors
  if (customStyle) {
    toast.style.cssText += customStyle;
  }
  
  // Apply rarity-specific styling if it's a rarity class
  if (colorClass && colorClass.indexOf('rarity-') === 0) {
    var rarityColors = {
      'rarity-normal': { border: '#9CA3AF', text: '#D1D5DB' },
      'rarity-rare': { border: '#3B82F6', text: '#60A5FA' },
      'rarity-epic': { border: '#8B5CF6', text: '#A78BFA' },
      'rarity-legendary': { border: '#F59E0B', text: '#FBBF24' },
      'rarity-mythic': { border: '#EC4899', text: '#F472B6' }
    };
    var rc = rarityColors[colorClass];
    if (rc) {
      toast.style.borderColor = rc.border;
      toast.style.color = rc.text;
      toast.style.textShadow = '0 0 8px ' + rc.border;
    }
  }
  
  toastContainer.appendChild(toast);
  
  // Limit to 3 toasts
  while (toastContainer.children.length > 3) {
    toastContainer.removeChild(toastContainer.firstChild);
  }
  
  // Remove after animation (longer for legendary/mythic)
  var duration = (colorClass === 'rarity-mythic') ? 2500 : (colorClass === 'rarity-legendary') ? 2000 : 1500;
  setTimeout(function() {
    if (toast.parentNode) toast.parentNode.removeChild(toast);
  }, duration);
}

// ============================================================
// STREAK ANNOUNCEMENTS
// ============================================================
var STREAK_THRESHOLDS = [
  { at: 10, text: "10x!", color: "" },
  { at: 20, text: "20x GREAT!", color: "gold" },
  { at: 30, text: "30x AMAZING!", color: "gold" },
  { at: 50, text: "50x GODLIKE!", color: "pink" },
  { at: 75, text: "75x LEGENDARY!", color: "cyan" },
  { at: 100, text: "100x MYTHIC!", color: "cyan" }
];

var lastAnnouncedStreak = 0;

function checkStreakAnnouncement() {
  for (var i = STREAK_THRESHOLDS.length - 1; i >= 0; i--) {
    var t = STREAK_THRESHOLDS[i];
    if (streak.hits >= t.at && lastAnnouncedStreak < t.at) {
      showToast(t.text, t.color);
      lastAnnouncedStreak = t.at;
      if (t.at >= 30) {
        spawnFirework(rand(100, canvas.width - 100), rand(100, canvas.height / 3));
      }
      beep(880, 0.08, 0.06);
      break;
    }
  }
}

// ============================================================
// MILESTONES
// ============================================================
function checkMilestones() {
  for (var i = 0; i < CONFIG.MILESTONES.length; i++) {
    var m = CONFIG.MILESTONES[i];
    if (state.score >= m && state.lastMilestone < m) {
      state.lastMilestone = m;
      var bonus = Math.floor(m * 0.05);
      state.score += bonus;
      showToast(formatNumber(m) + "! +" + formatNumber(bonus), "gold");
      state.screenShake = 10;
      spawnFirework(canvas.width / 2, canvas.height / 3);
      beep(660, 0.1, 0.08);
      beep(880, 0.1, 0.08);
      break;
    }
  }
}

function formatNumber(n) {
  if (n >= 1000000) return (n / 1000000).toFixed(1) + "M";
  if (n >= 1000) return (n / 1000).toFixed(0) + "K";
  return String(n);
}

// ============================================================
// NEAR MISS SYSTEM
// ============================================================
function checkNearMisses() {
  if (state.nearMissCooldown > 0) return;
  if (state.invulnT > 0 || hasPowerup("SHIELD")) return;
  
  var px = player.x + player.w / 2;
  var py = player.y + player.h / 2;
  
  for (var i = 0; i < enemyBullets.length; i++) {
    var b = enemyBullets[i];
    var bx = b.x + b.w / 2;
    var by = b.y + b.h / 2;
    var d = dist(px, py, bx, by);
    
    if (d < CONFIG.NEAR_MISS_DISTANCE && d > 12) {
      triggerNearMiss();
      break;
    }
  }
}

function triggerNearMiss() {
  state.nearMissCooldown = 0.25;
  state.nearMissCount++;
  state.totalNearMisses++;
  
  var pts = Math.floor(CONFIG.NEAR_MISS_POINTS * state.multiplier);
  state.score += pts;
  boostMultiplier(CONFIG.NEAR_MISS_MULT_BOOST);
  
  nearMissIndicator.classList.add("flash");
  setTimeout(function() { nearMissIndicator.classList.remove("flash"); }, 200);
  
  addFloatText(player.x + player.w / 2, player.y - 25, "+" + pts, "nearmiss");
  beep(1200, 0.02, 0.02);
}

// ============================================================
// MULTIPLIER SYSTEM
// ============================================================
function updateMultiplier(dt) {
  if (state.multiplierDecay > 0) {
    state.multiplierDecay -= dt;
  } else if (state.multiplier > 1.0) {
    state.multiplier = Math.max(1.0, state.multiplier - dt * 0.15);
  }
  updateMultiplierUI();
}

function updateMultiplierUI() {
  var pct = ((state.multiplier - 1) / 4) * 100;
  multiplierBar.querySelector(".mult-label").textContent = "x" + state.multiplier.toFixed(1);
  multiplierBar.querySelector(".mult-fill").style.width = pct + "%";
  multiplierBar.classList.toggle("active", state.multiplier > 1.0);
}

function boostMultiplier(amount) {
  state.multiplier = Math.min(5.0, state.multiplier + amount);
  state.multiplierDecay = 2.5;
}

// ============================================================
// RISK ZONE SYSTEM
// ============================================================
function updateRiskZone() {
  var nearestEnemy = Infinity;
  for (var i = 0; i < enemies.length; i++) {
    var e = enemies[i];
    if (!e.alive) continue;
    var d = dist(player.x + player.w/2, player.y + player.h/2, e.x + e.w/2, e.y + e.h/2);
    nearestEnemy = Math.min(nearestEnemy, d);
  }
  
  var threshold = canvas.height * CONFIG.RISK_ZONE_THRESHOLD;
  state.inRiskZone = nearestEnemy < threshold && enemies.length > 0;
  riskIndicator.classList.toggle("active", state.inRiskZone);
}

// ============================================================
// REVENGE MODE
// ============================================================
function activateRevenge() {
  state.revengeTimer = CONFIG.REVENGE_DURATION;
  revengeBadge.classList.add("active");
  showToast("REVENGE!", "danger");
  beep(200, 0.1, 0.08);
}

function updateRevenge(dt) {
  if (state.revengeTimer > 0) {
    state.revengeTimer -= dt;
    if (state.revengeTimer <= 0) {
      revengeBadge.classList.remove("active");
    }
  }
}

function getRevengeMult() {
  return state.revengeTimer > 0 ? CONFIG.REVENGE_DAMAGE_MULT : 1.0;
}

// ============================================================
// PERFECT WAVE
// ============================================================
function awardPerfectWave() {
  if (!state.perfectWave) return;
  var bonus = CONFIG.PERFECT_WAVE_BONUS * state.wave;
  state.score += bonus;
  showToast("PERFECT! +" + bonus, "gold");
  boostMultiplier(0.3);
  spawnFirework(canvas.width / 2, canvas.height / 3);
}

// ============================================================
// COMBO SYSTEM
// ============================================================
function registerHit() {
  streak.hits += 1;
  recalcStreakBonus();
  state.combo += 1;
  state.comboTimer = 3.5;
  if (state.combo > state.maxCombo) state.maxCombo = state.combo;
  boostMultiplier(0.015);
  checkStreakAnnouncement();
  
  // V9: Track wave stats
  state.waveShotsHit++;
  state.waveKills++;
}

function registerMiss() {
  streak.hits = 0;
  streak.bonusPct = 0;
  state.combo = 0;
  lastAnnouncedStreak = 0;
  
  // V9: Track shots fired (miss = shot fired but missed)
  state.waveShotsFired++;
}

// ============================================================
// HIGHSCORE SYSTEM
// ============================================================
var HIGHSCORE_KEY = "m4nfroid_galactica_v7_highscores";
var highscores = [];
var pendingHighscore = null;
var nameChars = ["A", "A", "A"];
var activeCharIndex = 0;
var CHAR_OPTIONS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ";

function loadHighscores() {
  try {
    var data = localStorage.getItem(HIGHSCORE_KEY);
    highscores = data ? JSON.parse(data) : [];
  } catch(e) { highscores = []; }
}

function saveHighscores() {
  try { localStorage.setItem(HIGHSCORE_KEY, JSON.stringify(highscores)); } catch(e) {}
}

function isHighscore(score) {
  if (highscores.length < 10) return true;
  return score > highscores[highscores.length - 1].score;
}

function addHighscore(name, score, wave) {
  highscores.push({ name: name, score: score, wave: wave, date: Date.now() });
  highscores.sort(function(a, b) { return b.score - a.score; });
  highscores = highscores.slice(0, 10);
  saveHighscores();
}

function renderHighscoreTable(arg1, arg2) {
  var targetEl = highscoreTable;
  var highlightScore = null;
  if (arg1 && typeof arg1 === "object" && "innerHTML" in arg1) {
    targetEl = arg1;
    highlightScore = arg2;
  } else {
    highlightScore = arg1;
  }

  var html = "";
  for (var i = 0; i < highscores.length; i++) {
    var hs = highscores[i];
    var isHighlight = highlightScore && hs.score === highlightScore;
    html += '<div class="hs-row ' + (isHighlight ? "highlight" : "") + '">' +
      '<span class="hs-rank">' + (i + 1) + '.</span>' +
      '<span class="hs-name">' + hs.name + '</span>' +
      '<span class="hs-score">' + hs.score.toLocaleString() + '</span>' +
      '</div>';
  }

  for (var j = highscores.length; j < 10; j++) {
    html += '<div class="hs-row">' +
      '<span class="hs-rank">' + (j + 1) + '.</span>' +
      '<span class="hs-name">---</span>' +
      '<span class="hs-score">-</span>' +
      '</div>';
  }
  targetEl.innerHTML = html;
}

function setupNameEntry() {
  nameChars = ["A", "A", "A"];
  activeCharIndex = 0;
  updateNameDisplay();
  document.getElementById("charUp").onclick = function() { cycleChar(1); };
  document.getElementById("charDown").onclick = function() { cycleChar(-1); };
  document.getElementById("charNext").onclick = function() { nextChar(); };
  document.getElementById("confirmName").onclick = function() { confirmName(); };
}

function cycleChar(dir) {
  var currentIndex = CHAR_OPTIONS.indexOf(nameChars[activeCharIndex]);
  var newIndex = currentIndex + dir;
  if (newIndex < 0) newIndex = CHAR_OPTIONS.length - 1;
  if (newIndex >= CHAR_OPTIONS.length) newIndex = 0;
  nameChars[activeCharIndex] = CHAR_OPTIONS[newIndex];
  updateNameDisplay();
  beep(440 + newIndex * 10, 0.03, 0.02);
}

function nextChar() {
  document.getElementById("char" + activeCharIndex).classList.remove("active");
  activeCharIndex = (activeCharIndex + 1) % 3;
  document.getElementById("char" + activeCharIndex).classList.add("active");
  beep(660, 0.04, 0.03);
}

function updateNameDisplay() {
  for (var i = 0; i < 3; i++) {
    document.getElementById("char" + i).textContent = nameChars[i];
    document.getElementById("char" + i).classList.toggle("active", i === activeCharIndex);
  }
}

function confirmName() {
  var name = nameChars.join("");
  addHighscore(name, pendingHighscore.score, pendingHighscore.wave);
  nameEntry.style.display = "none";
  renderHighscoreTable(pendingHighscore.score);
  pendingHighscore = null;
  beep(880, 0.1, 0.05);
  beep(1100, 0.1, 0.05);
}

// ============================================================
// POWER-UP SYSTEM - PERSISTENT WEAPONS INTACT
// ============================================================
var POWERUP_TYPES = {
  SHIELD: { name: "SHIELD", duration: 20, icon: "S", color: "#00d4ff" },
  RAPID: { name: "RAPID", duration: 9, icon: "R", color: "#ffaa00" },
  MULTI: { name: "MULTI", duration: 7, icon: "M", color: "#00ff88" },
  SPEED: { name: "SPEED", duration: 4, icon: "SP", color: "#ff00ff" },
  NUKE: { name: "NUKE", duration: 0, icon: "N", color: "#ff0000" },
  HEART: { name: "LIFE", duration: 0, icon: "+", color: "#ff3366" },
  ARMOR: { name: "ARMOR", duration: 0, icon: "A", color: "#888888" },
  DUALSHOT: { name: "DUAL", duration: -1, icon: "D", color: "#ffcc00" },
  LASER: { name: "LASER", duration: -1, icon: "L", color: "#ff0066" },
  KABOOM: { name: "BOOM", duration: -1, icon: "K", color: "#ff6600" }
};

var activePowerups = [];
var powerupDrops = [];

var permanentUpgrades = {
  dualshot: false, laser: false, kaboom: false,
  dualshotLevel: 0, laserLevel: 0, kaboomLevel: 0
};
var armor = 0;

function armorCap(){
  return 3 + getShipUpgLevel('acap');
}

function deflectChance(){
  return getShipUpgLevel('def') * 0.06; // 6% per level
}

function tryDeflectHit(){
  var c = deflectChance();
  if (c <= 0) return false;
  if (Math.random() < c) {
    showToast('DEFLECT!', '');
    beep(1200, 0.08, 0.05);
    return true;
  }
  return false;
}

/* ============================================================
   SHIP MILESTONE UPGRADES (persistent)
   - 2 options + 1 reroll per milestone (every 25 levels)
   ============================================================ */
var SHIP_UPG_KEY = "GALACTICA_SHIP_UPGRADES_V1";
var shipUpgrades = loadShipUpgrades();

var shipUpgradeDefs = [
  // COMMON
  { id:"rof", name:"Fire Rate+", tier:"common", cat:"Offense", max:5,
    desc:function(l){ return "-5% fire cooldown (currently " + (l*5) + "%)"; } },
  { id:"dmg", name:"Damage+", tier:"common", cat:"Offense", max:5,
    desc:function(l){ return "+8% bullet damage (currently " + (l*8) + "%)"; } },
  { id:"spd", name:"Speed+", tier:"common", cat:"Mobility", max:5,
    desc:function(l){ return "+5% ship speed (currently " + (l*5) + "%)"; } },
  { id:"xp", name:"XP Boost", tier:"common", cat:"Utility", max:5,
    desc:function(l){ return "+10% XP gain (currently " + (l*10) + "%)"; } },
  { id:"mag", name:"Magnet", tier:"common", cat:"Utility", max:5,
    desc:function(l){ return "+12px pickup radius (currently +" + (l*12) + "px)"; } },

  // RARE
  { id:"msi", name:"Missile Cadence", tier:"rare", cat:"Offense", max:5,
    desc:function(l){ return "-6% cruise missile interval (currently " + (l*6) + "%)"; } },
  { id:"msd", name:"Missile Damage", tier:"rare", cat:"Offense", max:5,
    desc:function(l){ return "+12% cruise missile damage (currently " + (l*12) + "%)"; } },
  { id:"def", name:"Deflector", tier:"rare", cat:"Defense", max:4,
    desc:function(l){ return (l*6) + "% chance to negate a hit"; } },
  { id:"arm", name:"Armor Plating", tier:"rare", cat:"Defense", max:3,
    desc:function(l){ return "Start runs with +" + l + " armor"; } },

  // EPIC
  { id:"acap", name:"Armor Capacity", tier:"epic", cat:"Defense", max:2,
    desc:function(l){ return "Armor cap +" + l + " (max " + (3 + l) + ")"; } },
  { id:"life", name:"Extra Life", tier:"epic", cat:"Defense", max:2,
    desc:function(l){ return "Start runs with +" + l + " extra life"; } }
];

var upgradeModalOpen = false;
var pendingMilestones = [];

var debriefActive = false;
var debriefQueue = [];           // queued pick steps for current debrief
var debriefCompletedWave = 0;

// Run-only tactical boosts (presented in debrief)
var tacticalBoostDefs = [
  { id:"MULTI", name:"POSEIDON SPEAR", tier:"rare",  label:"POSEIDON SPEAR",  subtitle:"+Multi-Shot for a short burst",   icon:"‚öúÔ∏è", desc:"Triple shot spread for 20 seconds" },
  { id:"RAPID", name:"OVERDRIVE", tier:"common",label:"OVERDRIVE",       subtitle:"Rapid fire systems online",      icon:"‚ö°", desc:"Double fire rate for 15 seconds" },
  { id:"SPEED", name:"THRUSTER SURGE", tier:"common",label:"THRUSTER SURGE",  subtitle:"Speed burst for repositioning",  icon:"üí®", desc:"+50% movement speed for 15 seconds" },
  { id:"SHIELD",name:"AETHER SHIELD", tier:"rare",  label:"AETHER SHIELD",   subtitle:"Protective field (longer lasting)", icon:"üõ°Ô∏è", desc:"Immunity to damage for 10 seconds" },
  { id:"ARMOR", name:"HULL PLATING", tier:"common",label:"HULL PLATING",    subtitle:"+1 armor (up to cap)",           icon:"üß±", desc:"Gain +1 armor point" },
  { id:"HEART", name:"MED CORE", tier:"rare",  label:"MED CORE",        subtitle:"+1 life (if not capped)",        icon:"‚ù§Ô∏è", desc:"Restore +1 life" }
];

function clearProjectilesForDebrief(){
  // Ensure no ‚Äúresume into bullet‚Äù edge cases
  playerBullets = [];
  enemyBullets = [];
  cruiseMissiles = [];
  shockwaves = [];
  powerupDrops = [];
}

function beginDebrief(completedWave){
  debriefActive = true;
  debriefCompletedWave = completedWave;

  // Pause
  state.running = false;

  clearProjectilesForDebrief();
  // ============================================================
  // V9 LOOT SYSTEM: Calculate performance and show panels
  // ============================================================
  var waveStats = {
    kills: state.waveKills || 0,
    accuracy: (state.waveShotsFired + state.waveShotsHit) > 0 ? state.waveShotsHit / (state.waveShotsFired + state.waveShotsHit) : 0.5,
    time: (performance.now() - (state.waveStartTime || performance.now())) / 1000,
    damageTaken: state.waveDamageTaken || 0
  };
  
  var isBossWave = completedWave % 20 === 0;
  var gradeResult = LootSystem.calculatePerformanceGrade(waveStats);
  
  // Award scrap based on grade
  var baseScrap = LOOT_DATA.debriefRewards.waveCompletion.baseScrap || 50;
  var perWave = LOOT_DATA.debriefRewards.waveCompletion.scrapPerWave || 10;
  var bossBonus = isBossWave ? (LOOT_DATA.debriefRewards.waveCompletion.bossBonus || 200) : 0;
  var scrapEarned = Math.floor((baseScrap + (completedWave * perWave) + bossBonus) * gradeResult.scrapMultiplier);
  addScrap(scrapEarned);
  
  // Show grade panel
  showDebriefGrade({ grade: gradeResult.grade, scrap: scrapEarned, kills: waveStats.kills, score: gradeResult.score });
  
  // Generate vendor stock and render panels
  generateVendorStock(completedWave);
  renderCollectedLoot();
  renderVendorShop();

  // Build queue: up to N persistent picks + 1 tactical pick
  debriefQueue = [];
  var picks = Math.min(CONFIG.DEBRIEF_MAX_PICKS, pendingMilestones.length);
  for (var i=0;i<picks;i++){
    debriefQueue.push({ type:"PERSISTENT", level: pendingMilestones.shift() });
  }
  // Always offer 1 tactical boost so ‚Äúbeides‚Äù (persistent + run-only) happens naturally.
  debriefQueue.push({ type:"TACTICAL", level: completedWave });

  showNextDebriefStep();
}

function showNextDebriefStep(){
  if (debriefQueue.length === 0) {
    endDebriefAndAdvance();
    return;
  }
  var step = debriefQueue[0];
  if (step.type === "PERSISTENT") {
    showUpgradeModal(step.level, {
      mode: "PERSISTENT",
      title: "MISSION DEBRIEF",
      subtitle: "Recovered Alien Artifacts  ‚Ä¢  Pick 1 ship upgrade",
      rerollsLeft: 1
    });
  } else {
    // Tactical boost selection (run-only)
    showUpgradeModal(step.level, {
      mode: "TACTICAL",
      title: "TACTICAL LOADOUT",
      subtitle: "Choose 1 boost for the next 20-wave sector",
      rerollsLeft: 1,
      tacticalPool: tacticalBoostDefs
    });
  }
}

function endDebriefAndAdvance(){
  debriefActive = false;
  debriefCompletedWave = 0;

  // Close overlay
  if (typeof upgradeScreen !== "undefined" && upgradeScreen) upgradeScreen.classList.remove("active");
  // Hide parent overlay to return to gameplay view
  hideOverlay();
  currentUpgradeContext = null;
  upgradeModalOpen = false;

  // ============================================================
  // V9 LOOT SYSTEM: Clean up debrief panels
  // ============================================================
  hideDebriefPanels();
  
  // Clear sector inventory (loot was applied or sold in debrief)
  clearSectorLoot();
  
  // Reset wave stats for next sector
  state.waveKills = 0;
  state.waveAccuracy = 0;
  state.waveTime = 0;
  state.waveDamageTaken = 0;
  state.waveShotsFired = 0;
  state.waveShotsHit = 0;
  state.waveStartTime = performance.now();
  
  // Reset loot drops per wave counter
  LootSystem.resetWaveDrops();

  // Give a short invuln window on resume
  state.invulnT = Math.max(state.invulnT, 0.6);

  // Advance to next wave now that choices are done
  advanceToNextWave();

  // Resume loop
  lastT = performance.now();
  state.running = true;
  requestAnimationFrame(loop);
}
var currentUpgradeContext = null;

function loadShipUpgrades(){
  try { return JSON.parse(localStorage.getItem(SHIP_UPG_KEY) || "{}"); }
  catch(e){ return {}; }
}
function saveShipUpgrades(){
  try { localStorage.setItem(SHIP_UPG_KEY, JSON.stringify(shipUpgrades)); } catch(e) {}
}
function getShipUpgLevel(id){ return shipUpgrades[id] ? shipUpgrades[id] : 0; }
function canUpgrade(id){
  var def = getUpgradeDef(id);
  return def && getShipUpgLevel(id) < def.max;
}
function getUpgradeDef(id){
  for (var i=0;i<shipUpgradeDefs.length;i++) if (shipUpgradeDefs[i].id===id) return shipUpgradeDefs[i];
  return null;
}

function milestoneMaybeOffer(level){
  // Earn upgrade picks via player level, but only present them in Debriefs (no mid-combat popups)
  if (level % CONFIG.MILESTONE_INTERVAL !== 0) return;
  pendingMilestones.push(level);
}


function openNextMilestone(){
  if (pendingMilestones.length === 0) { upgradeModalOpen = false; return; }
  upgradeModalOpen = true;

  var lvl = pendingMilestones.shift();
  // Pause loop
  if (state.running) { state.running = false; }
  showUpgradeModal(lvl);
}

function showUpgradeModal(level, opts){
  opts = opts || {};
  currentUpgradeContext = {
    mode: opts.mode || "PERSISTENT",       // PERSISTENT | TACTICAL
    milestoneLevel: level,
    rerollsLeft: (typeof opts.rerollsLeft === "number") ? opts.rerollsLeft : 1,
    lastOptionIds: [],
    // For TACTICAL choices
    tacticalPool: opts.tacticalPool || null
  };

  if (upgradeTitle) upgradeTitle.textContent = opts.title || (currentUpgradeContext.mode === "TACTICAL" ? "TACTICAL LOADOUT" : "MISSION DEBRIEF");
  upgradeSub.textContent = opts.subtitle || (currentUpgradeContext.mode === "TACTICAL"
    ? "Choose 1 boost for the next sector"
    : ("Recovered Alien Artifacts  ‚Ä¢  LEVEL " + level + "  ‚Ä¢  Pick 1 upgrade"));

    upgradeModalOpen = true;
  // Ensure parent overlay is visible (upgrade screens are nested inside #overlay)
  overlay.style.display = "flex";
  upgradeScreen.classList.add("active");
  renderUpgradeOptions(true);
}



function renderUpgradeOptions(isFirst){
  var ctx = currentUpgradeContext;
  if (!ctx) return;

  var isTactical = (ctx.mode === 'TACTICAL');
  var options;
if (isTactical) {
  options = rollTacticalOptions(2, ctx.lastOptionIds, ctx.tacticalPool || tacticalBoostDefs);
  ctx.lastOptionIds = options.map(function(o){ return o.id; });
} else {
  options = rollUpgradeOptions(2, ctx.lastOptionIds, ctx.milestoneLevel);
  // Force at least one Offense option when possible (prevents ‚Äúno damage upgrades for too long‚Äù)
  var hasOffense = false;
  for (var oi=0;oi<options.length;oi++) if (options[oi].cat === "Offense") hasOffense = true;
  if (!hasOffense) {
    var forced = forceOffenseOption(ctx.lastOptionIds, ctx.milestoneLevel);
    if (forced) options[0] = forced;
  }
  ctx.lastOptionIds = options.map(function(o){ return o.id; });
}
upgradeOptions.innerHTML = "";
  for (var i=0;i<options.length;i++){
    (function(def){
      var lvl = getShipUpgLevel(def.id);
      var nextLvl = Math.min(def.max, lvl+1);

      var btn = document.createElement("button");
      btn.className = "upgradeCard";
      btn.type = "button";

      var tier = (def.tier || "common");
      var cat = (def.cat || "General");
      var tierLabel = tier.toUpperCase();

      var upDesc = (typeof def.desc === "function") ? String(def.desc(nextLvl) || "") : String(def.desc || "");

      btn.innerHTML =
        '<div class="upHead">' +
          '<div class="upName">' + def.name + '</div>' +
          '<div class="tierBadge tier-' + tier + '">' + tierLabel + '</div>' +
        '</div>' +
        '<div class="upDesc">' + upDesc + '</div>' +
        '<div class="upMeta">' + cat + ' ‚Ä¢ Level ' + lvl + '/' + def.max + '</div>';

      btn.addEventListener("click", function(e){
        e.preventDefault(); e.stopPropagation();
        if (isTactical) pickTactical(def.id); else pickUpgrade(def.id);
      });
      upgradeOptions.appendChild(btn);
    })(options[i]);
  }

  btnUpgradeReroll.textContent = "REROLL (" + ctx.rerollsLeft + ")";
  btnUpgradeReroll.disabled = ctx.rerollsLeft <= 0;
}

function rollTacticalOptions(n, avoidIds, pool){
  avoidIds = avoidIds || [];
  pool = pool || tacticalBoostDefs;
  // avoid repeating the same option after reroll
  var cands = [];
  for (var i=0;i<pool.length;i++){
    if (avoidIds.indexOf(pool[i].id) !== -1) continue;
    cands.push(pool[i]);
  }
  if (cands.length === 0) cands = pool.slice();

  function weightFor(def){
    // rare a bit less frequent than common
    return (def.tier === "rare") ? 0.75 : 1.0;
  }

  var out = [];
  var used = {};
  for (var k=0;k<n;k++){
    var sum = 0, weights = [];
    for (var i=0;i<cands.length;i++){
      var d=cands[i];
      if (used[d.id]) { weights.push(0); continue; }
      var w=weightFor(d);
      weights.push(w);
      sum += w;
    }
    if (sum <= 0) break;
    var r=Math.random()*sum;
    for (var i=0;i<cands.length;i++){
      r -= weights[i];
      if (r <= 0) { out.push(cands[i]); used[cands[i].id]=true; break; }
    }
  }
  return out;
}

function forceOffenseOption(avoidIds, milestoneLevel){
  // Try to pull a non-maxed offense upgrade as a safety valve for late-game scaling
  var best = null;
  for (var i=0;i<shipUpgradeDefs.length;i++){
    var d=shipUpgradeDefs[i];
    if (d.cat !== "Offense") continue;
    if (!canUpgrade(d.id)) continue;
    if (avoidIds && avoidIds.indexOf(d.id)!==-1) continue;
    best = d; break;
  }
  return best;
}

function pickTactical(id){
  // Apply immediately (we are between waves in Debrief)
  addPowerup(id);

  // Continue queue
  if (debriefActive) {
    debriefQueue.shift();
    showNextDebriefStep();
    return;
  }

  // Fallback: close
  if (typeof upgradeScreen !== "undefined" && upgradeScreen) upgradeScreen.classList.remove("active");
  currentUpgradeContext = null;
  upgradeModalOpen = false;

  lastT = performance.now();
  state.running = true;
  requestAnimationFrame(loop);
}
function rollUpgradeOptions(n, avoidIds, milestoneLevel){
  avoidIds = avoidIds || [];
  milestoneLevel = milestoneLevel || 20;

  // candidate pool: not maxed
  var pool = [];
  for (var i=0;i<shipUpgradeDefs.length;i++){
    var d = shipUpgradeDefs[i];
    if (canUpgrade(d.id)) pool.push(d);
  }
  // if everything maxed, still show something (fallback to any)
  if (pool.length === 0) pool = shipUpgradeDefs.slice();

  function tierWeightsFor(level){
    var steps = Math.max(0, Math.floor((level - 20) / 20)); // 0 at lvl20
    var common = Math.max(45, 70 - steps * 5);
    var rare   = Math.min(40, 25 + steps * 3);
    var epic   = 100 - common - rare;
    epic = Math.max(5, Math.min(25, epic));
    // rebalance to sum 100
    var total = common + rare + epic;
    return {
      common: common / total,
      rare: rare / total,
      epic: epic / total
    };
  }

  function pickWeighted(cands, level){
    if (!cands || cands.length === 0) return null;
    var tw = tierWeightsFor(level);
    var sum = 0;
    var weights = [];
    for (var i=0;i<cands.length;i++){
      var t = cands[i].tier || "common";
      var w = (t === "epic") ? tw.epic : (t === "rare" ? tw.rare : tw.common);
      // optional per-upgrade weight
      if (typeof cands[i].weight === "number") w *= Math.max(0.05, cands[i].weight);
      weights.push(w);
      sum += w;
    }
    var r = Math.random() * sum;
    for (var j=0;j<cands.length;j++){
      r -= weights[j];
      if (r <= 0) return cands[j];
    }
    return cands[cands.length-1];
  }

  function buildCandidates(exclude, forbidCat){
    exclude = exclude || {};
    var cands = [];
    for (var i=0;i<pool.length;i++){
      var d = pool[i];
      if (exclude[d.id]) continue;
      if (avoidIds.indexOf(d.id) !== -1) continue;
      if (forbidCat && d.cat === forbidCat) continue;
      cands.push(d);
    }
    return cands;
  }

  function pickOne(exclude, forbidCat){
    // 1) try with category restriction
    var cands = buildCandidates(exclude, forbidCat);
    // 2) relax category if needed
    if (cands.length === 0) cands = buildCandidates(exclude, null);
    // 3) last resort: anything not excluded
    if (cands.length === 0){
      for (var i=0;i<pool.length;i++){
        if (!exclude[pool[i].id]) cands.push(pool[i]);
      }
    }
    return pickWeighted(cands, milestoneLevel) || pool[0];
  }

  var out = [];
  var excl = {};
  var first = pickOne(excl, null);
  out.push(first);
  excl[first.id] = true;

  // anti-dupe: option 2 tries to be a different category
  if (n > 1){
    var second = pickOne(excl, first.cat || null);
    out.push(second);
    excl[second.id] = true;
  }

  // if n > 2, fill remaining without constraints beyond no duplicates
  for (var k=2;k<n;k++){
    var more = pickOne(excl, null);
    out.push(more);
    excl[more.id] = true;
  }

  return out;
}


function pickUpgrade(id){
  var def = getUpgradeDef(id);
  if (!def) return;

  var lvl = getShipUpgLevel(id);
  if (lvl < def.max) {
    shipUpgrades[id] = lvl + 1;
    saveShipUpgrades();
  }

  // Apply immediate effects that matter mid-run
  applyShipUpgradesRuntime();

  // Close or continue queue
if (debriefActive) {
  debriefQueue.shift();
  // Keep overlay open; move to next step
  showNextDebriefStep();
  return;
}

if (pendingMilestones.length > 0) {
  // (Legacy) If something called a milestone modal directly, keep paused and show next
  showUpgradeModal(pendingMilestones.shift(), { mode:"PERSISTENT", title:"SHIP UPGRADE" });
  return;
}

// Done
if (typeof upgradeScreen !== "undefined" && upgradeScreen) upgradeScreen.classList.remove("active");
currentUpgradeContext = null;
upgradeModalOpen = false;

  // Resume loop
  lastT = performance.now();
  state.running = true;
  requestAnimationFrame(loop);
}

function applyShipUpgradesRuntime(){
  // Recompute player speed (safe mid-run)
  if (player) {
    var base = player.baseSpeed || (isPortrait() ? 450 : 500);
    player.baseSpeed = base;
    player.speed = base * (1 + getShipUpgLevel("spd") * 0.05);
  }
  updateHUD();
}

setupMenuButton(btnUpgradeReroll, function(){
  if (!currentUpgradeContext) return;
  if (currentUpgradeContext.rerollsLeft <= 0) return;
  currentUpgradeContext.rerollsLeft -= 1;
  renderUpgradeOptions(false);
});


function hasPowerup(type) {
  for (var i = 0; i < activePowerups.length; i++) {
    if (activePowerups[i].type === type) return true;
  }
  return false;
}

function getPowerupTimer(type) {
  for (var i = 0; i < activePowerups.length; i++) {
    if (activePowerups[i].type === type) return activePowerups[i].timer;
  }
  return 0;
}

function addPowerup(type) {
  if (type === "NUKE") { triggerNuke(); return; }
  
  if (type === "HEART") {
    if (state.lives < 5) {
      state.lives += 1;
      showToast("+1 LIFE!", "pink");
      beep(523, 0.1, 0.08); beep(659, 0.1, 0.08); beep(784, 0.15, 0.1);
    } else {
      state.score += 500;
      showToast("+500 BONUS!", "gold");
    }
    updateHUD();
    return;
  }
  
  if (type === "ARMOR") {
    if (armor < armorCap()) {
      armor += 1;
      showToast("ARMOR +" + armor + "/" + armorCap(), "");
      beep(440, 0.12, 0.08); beep(554, 0.12, 0.08);
    } else {
      state.score += 300;
      showToast("+300 BONUS!", "gold");
    }
    updateHUD();
    return;
  }
  
  // PERSISTENT WEAPON UPGRADES
  if (type === "DUALSHOT" || type === "LASER" || type === "KABOOM") {
    handleWeaponUpgrade(type);
    return;
  }

  var existing = null;
  for (var i = 0; i < activePowerups.length; i++) {
    if (activePowerups[i].type === type) { existing = activePowerups[i]; break; }
  }
  if (existing) {
    existing.timer = POWERUP_TYPES[type].duration;
  } else {
    activePowerups.push({ type: type, timer: POWERUP_TYPES[type].duration });
  }
  updatePowerupUI();
  beep(880, 0.1, 0.1);
}

function handleWeaponUpgrade(type) {
  var key = type.toLowerCase();
  var otherWeapons = ["dualshot", "laser", "kaboom"].filter(function(w) { return w !== key; });
  var switchingWeapon = otherWeapons.some(function(w) { return permanentUpgrades[w]; });
  
  if (switchingWeapon) {
    otherWeapons.forEach(function(w) { permanentUpgrades[w] = false; permanentUpgrades[w + "Level"] = 0; });
    permanentUpgrades[key] = true;
    permanentUpgrades[key + "Level"] = 1;
    showToast(type + " LVL 1!", "gold");
  } else if (permanentUpgrades[key] && permanentUpgrades[key + "Level"] < 5) {
    permanentUpgrades[key + "Level"] += 1;
    var lvl = permanentUpgrades[key + "Level"];
    showToast(type + " LVL " + lvl + "!", "gold");
    state.screenShake = 6;
  } else if (permanentUpgrades[key + "Level"] >= 5) {
    state.score += 1000;
    showToast(type + " MAX! +1000", "gold");
  } else {
    permanentUpgrades[key] = true;
    permanentUpgrades[key + "Level"] = 1;
    showToast(type + " UNLOCKED!", "gold");
  }
  
  beep(660, 0.15, 0.1);
  beep(880, 0.15, 0.1);
  updatePowerupUI();
}

function triggerNuke() {
  showToast("NUKE!", "danger");
  var killedCount = 0;
  for (var i = 0; i < enemies.length; i++) {
    var e = enemies[i];
    if (e.alive && e.type !== "boss") {
      e.hp = 0;
      e.alive = false;
      spawnMegaExplosion(e.x + e.w / 2, e.y + e.h / 2);
      state.score += 10;
      gainXP(CONFIG.XP_PER_KILL_BASE);
      killedCount++;
      registerHit();
    }
  }

  state.flashAlpha = 1;
  state.screenShake = 30;
  state.chromatic = 20;
  explosionSound();
  beep(200, 0.3, 0.2);

  if (killedCount > 0) {
    var allDead = true;
    for (var j = 0; j < enemies.length; j++) {
      if (enemies[j].alive) { allDead = false; break; }
    }
    if (allDead && !state.waveTransitioning) {
      state.waveTransitioning = true;
      setTimeout(function() { nextWave(); state.waveTransitioning = false; }, 1200);
    }
  }
}

function updatePowerupUI() {
  powerupBar.innerHTML = "";
  
  // Show persistent weapon upgrade
  if (permanentUpgrades.dualshot || permanentUpgrades.laser || permanentUpgrades.kaboom) {
    var permaDiv = document.createElement("div");
    permaDiv.style.cssText = "padding:4px 8px; background:rgba(255,215,0,.2); border:1px solid #ffd700; border-radius:4px; margin-bottom:4px; font-size:10px; font-weight:700; text-align:center; box-shadow:0 0 6px rgba(255,215,0,.3);";
    
    var weaponText = "", level = 0;
    if (permanentUpgrades.dualshot) { weaponText = "DUAL"; level = permanentUpgrades.dualshotLevel; }
    else if (permanentUpgrades.laser) { weaponText = "LASER"; level = permanentUpgrades.laserLevel; }
    else if (permanentUpgrades.kaboom) { weaponText = "BOOM"; level = permanentUpgrades.kaboomLevel; }
    
    var stars = "";
    for (var s = 0; s < 5; s++) stars += s < level ? "√¢Àú‚Ä¶" : "√¢Àú‚Ä†";
    permaDiv.innerHTML = weaponText + " L" + level + "<br><small style='font-size:8px;'>" + stars + "</small>";
    powerupBar.appendChild(permaDiv);
  }
  
  for (var i = 0; i < activePowerups.length; i++) {
    var p = activePowerups[i];
    var def = POWERUP_TYPES[p.type];
    var div = document.createElement("div");
    div.className = "powerup-active";
    if (p.type === "SHIELD" && p.timer <= 3) div.classList.add("warning");
    div.innerHTML = '<span>' + def.icon + '</span><span>' + def.name + '</span>' +
      '<div class="powerup-timer"><div class="powerup-timer-fill" style="width:' + ((p.timer / def.duration) * 100) + '%"></div></div>';
    powerupBar.appendChild(div);
  }
}

function spawnPowerupDrop(x, y) {
  // Phase 1 economy: fewer drops, less MULTI/SPEED spam (keeps moments rewarding)
  if (powerupDrops.length >= 7) return;
  if (Math.random() > CONFIG.NORMAL_DROP_CHANCE) return;

  var types = ["SHIELD", "RAPID", "MULTI", "SPEED", "NUKE", "HEART", "ARMOR"];
  // Base weights tuned for scarcity: MULTI/SPEED much rarer, shield rarer, hearts rarer.
  var weights = [12, 18, 6, 7, 2, 5, 4];

  // Avoid refresh-spam: if already active, heavily suppress that drop.
  if (hasPowerup("MULTI")) weights[2] = 0;
  if (hasPowerup("SPEED")) weights[3] *= 0.35;
  if (hasPowerup("RAPID")) weights[1] *= 0.50;
  if (hasPowerup("SHIELD")) weights[0] *= 0.55;

  // Fairness: hearts only really matter when not full.
  if (state.lives >= 5) weights[5] = 0.2;

  // Armor only if it can still be gained
  if (armor >= armorCap()) weights[6] = 0.15;

  // Nuke is spectacle: keep rare, and avoid wasting it on tiny groups
  if (enemies.length < 12) weights[4] *= 0.5;

  var totalWeight = 0;
  for (var w = 0; w < weights.length; w++) totalWeight += Math.max(0, weights[w]);
  if (totalWeight <= 0) return;

  var r = Math.random() * totalWeight;
  var type = types[0];
  for (var i = 0; i < types.length; i++) {
    r -= Math.max(0, weights[i]);
    if (r <= 0) { type = types[i]; break; }
  }

  var def = POWERUP_TYPES[type];
  powerupDrops.push({ x: x - 18, y: y - 18, w: 36, h: 36, type: type, vy: 90, color: def.color, pulse: 0, rotation: 0 });
}

// BOSS ALWAYS DROPS WEAPON + ARMOR
function spawnBossDrop(x, y) {
  var weapons = ["DUALSHOT", "LASER", "KABOOM"];
  var weapon = weapons[Math.floor(Math.random() * weapons.length)];
  var weaponDef = POWERUP_TYPES[weapon];
  powerupDrops.push({ x: x - 18, y: y - 18, w: 36, h: 36, type: weapon, vy: 90, color: weaponDef.color, pulse: 0, rotation: 0 });
  
  var armorCount = 2 + Math.floor(Math.random() * 3);
  for (var i = 0; i < armorCount; i++) {
    (function(idx) {
      setTimeout(function() {
        powerupDrops.push({ x: x - 18 + (Math.random() - 0.5) * 80, y: y - 18 + (Math.random() - 0.5) * 60, w: 36, h: 36, type: "ARMOR", vy: 90, color: "#888888", pulse: 0, rotation: 0 });
      }, idx * 100);
    })(i);
  }
}

// ============================================================
// ENTITIES
// ============================================================
var player, playerBullets, enemyBullets, enemies, particles, floatTexts, trails, shockwaves, fireworks;
var formation = { dir: 1, speed: 42, dropStep: 18, dropCooldown: 0, margin: 30 };

// ============================================================
// DIFFICULTY SCALING
// ============================================================
function waveTier10() { return Math.floor((state.wave - 1) / 10); }
function enemyHpMultiplier() { return Math.pow(1.09, waveTier10()) * (1 + state.wave * 0.022); }
function enemyTempoMultiplier() {
  var perLevel = 1 + 0.015 * (state.wave - 1);
  var per10 = 1 + 0.03 * waveTier10();
  return Math.min(2.5, perLevel * per10);
}
function getDifficultyFeatures() {
  return {
    zigzag: state.wave >= 3,
    divers: state.wave >= 5,
    homing: state.wave >= 8,
    shields: state.wave >= 10
  };
}
function isPortrait() { return canvas.height / canvas.width > 1.15; }

// ============================================================
// BACKGROUND
// ============================================================
var stars = [];
var nebulae = [];
var dustParticles = [];

function initStars() {
  stars.length = 0; nebulae.length = 0; dustParticles.length = 0;
  var n = Math.floor(250 * (isPortrait() ? 1.0 : 0.9));
  for (var i = 0; i < n; i++) {
    stars.push({
      x: Math.random() * bg.width, y: Math.random() * bg.height,
      z: Math.random(), twinkle: Math.random() * Math.PI * 2,
      color: randChoice(["#ffffff", "#aaddff", "#ffddaa", "#ddffdd", "#ffaaff"])
    });
  }
  for (var j = 0; j < 6; j++) {
    nebulae.push({ x: Math.random() * bg.width, y: Math.random() * bg.height, size: rand(150, 400), speed: rand(8, 20), hue: rand(0, 360), opacity: rand(0.03, 0.08) });
  }
  for (var k = 0; k < 50; k++) {
    dustParticles.push({ x: Math.random() * bg.width, y: Math.random() * bg.height, size: rand(1, 3), speed: rand(30, 80), opacity: rand(0.1, 0.3) });
  }
}

function drawStars(dt) {
  bctx.fillStyle = "#000508";
  bctx.fillRect(0, 0, bg.width, bg.height);

  for (var ni = 0; ni < nebulae.length; ni++) {
    var n = nebulae[ni];
    n.y += n.speed * dt; n.hue += dt * 2;
    if (n.y > bg.height + n.size) { n.y = -n.size; n.x = Math.random() * bg.width; }
    var gradient = bctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.size);
    gradient.addColorStop(0, "hsla(" + n.hue + ", 80%, 50%, " + n.opacity + ")");
    gradient.addColorStop(0.4, "hsla(" + (n.hue + 30) + ", 70%, 40%, " + (n.opacity * 0.5) + ")");
    gradient.addColorStop(1, "hsla(" + n.hue + ", 60%, 30%, 0)");
    bctx.fillStyle = gradient;
    bctx.fillRect(n.x - n.size, n.y - n.size, n.size * 2, n.size * 2);
  }

  for (var di = 0; di < dustParticles.length; di++) {
    var d = dustParticles[di];
    d.y += d.speed * dt;
    if (d.y > bg.height) { d.y = 0; d.x = Math.random() * bg.width; }
    bctx.globalAlpha = d.opacity;
    bctx.fillStyle = "#446688";
    bctx.fillRect(d.x, d.y, d.size, d.size);
  }

  var baseSpeed = 30 + 55 * (isPortrait() ? 1.05 : 1.0);
  for (var si = 0; si < stars.length; si++) {
    var s = stars[si];
    s.y += baseSpeed * (0.2 + s.z * 0.8) * dt;
    if (s.y > bg.height) { s.y = 0; s.x = Math.random() * bg.width; }
    s.twinkle += dt * (2 + s.z * 3);
    var twinkleAlpha = 0.4 + Math.sin(s.twinkle) * 0.4;
    bctx.globalAlpha = (0.2 + 0.6 * s.z) * twinkleAlpha;
    bctx.fillStyle = s.color;
    var size = 1 + s.z * 1.5;
    bctx.fillRect(s.x - size / 2, s.y - size / 2, size, size);
    if (s.z > 0.7) {
      bctx.globalAlpha = twinkleAlpha * 0.15;
      bctx.beginPath();
      bctx.arc(s.x, s.y, 3 + s.z * 2, 0, Math.PI * 2);
      bctx.fill();
    }
  }
  bctx.globalAlpha = 1;
}

// ============================================================
// PARTICLE SYSTEM
// ============================================================
function addFloatText(x, y, text, kind) {
  var big = streak.bonusPct >= 10;
  var isCrit = kind === "crit";
  var isNearMiss = kind === "nearmiss";
  var size = isCrit ? 22 : isNearMiss ? 14 : kind === "damage" ? (big ? 18 : 14) : (big ? 16 : 12);
  var color = isCrit ? "#ff0066" : isNearMiss ? "#00ffff" : kind === "damage" ? (big ? "#ffe74a" : "#ffffff") : (big ? "#7CFFB2" : "#B7FFD8");
  floatTexts.push({ x: x, y: y, text: text, life: 0.6, size: size, alpha: 1, color: color, vy: isCrit ? -70 : -45, vx: rand(-30, 30), scale: isCrit ? 1.4 : 1, rotation: rand(-0.15, 0.15) });
}

function spawnParticles(x, y, color, amount, speed) {
  amount = amount || 15;
  speed = speed || 1;
  var limit = Math.min(amount, CONFIG.PARTICLE_LIMIT - particles.length);
  for (var i = 0; i < limit; i++) {
    particles.push({ x: x, y: y, vx: rand(-150, 150) * speed, vy: rand(-180, 100) * speed, life: rand(0.4, 1.0), size: rand(1.5, 4), color: color, gravity: rand(120, 350), type: "normal" });
  }
}

function spawnSparkles(x, y, color, amount) {
  amount = amount || 10;
  for (var i = 0; i < amount; i++) {
    var angle = (Math.PI * 2 * i) / amount;
    var speed = rand(100, 200);
    particles.push({ x: x, y: y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: rand(0.3, 0.6), size: rand(2, 4), color: color, gravity: 50, type: "sparkle", decay: 0.95 });
  }
}

function spawnFirework(x, y, colorPalette) {
  var colors = colorPalette || ["#ff0066", "#00ff88", "#00d4ff", "#ffd700", "#ff6600", "#ff00ff", "#00ffff"];
  var color = randChoice(colors);
  var rings = randInt(1, 2);
  for (var ring = 0; ring < rings; ring++) {
    var particleCount = 8 + ring * 4;
    var baseSpeed = 120 + ring * 60;
    var delay = ring * 0.05;
    for (var i = 0; i < particleCount; i++) {
      (function(ii, bs, dl) {
        var angle = (Math.PI * 2 * ii) / particleCount + rand(-0.1, 0.1);
        var spd = bs * rand(0.8, 1.2);
        setTimeout(function() {
          if (!state.running) return;
          fireworks.push({ x: x, y: y, vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd, life: rand(0.6, 1.0), size: rand(2, 4), color: color, gravity: 80, trail: [], maxTrail: 5 });
        }, dl * 1000);
      })(i, baseSpeed, delay);
    }
  }
  shockwaves.push({ x: x, y: y, radius: 5, maxRadius: 40 + rings * 15, life: 0.6, color: color, width: 2 });
}

function spawnMegaExplosion(x, y, size) {
  size = size || "normal";
  var isBoss = size === "boss";
  var isBig = size === "big" || isBoss;
  var amount = isBoss ? 40 : isBig ? 25 : 15;
  var speedMult = isBoss ? 1.8 : isBig ? 1.3 : 1;
  var colors = isBoss ? ["#ff0000", "#ff3300", "#ff6600", "#ff9900", "#ffcc00", "#ffffff"] : ["#ff6600", "#ff9900", "#ffcc00", "#ff3300", "#ffffff"];

  for (var i = 0; i < amount; i++) {
    var angle = (Math.PI * 2 * i) / amount + rand(-0.3, 0.3);
    var spd = rand(80, 280) * speedMult;
    particles.push({ x: x, y: y, vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd, life: rand(0.5, 1.0), size: rand(2, isBoss ? 5 : 4), color: randChoice(colors), gravity: 180, type: "explosion" });
  }

  var debrisCount = isBoss ? 8 : isBig ? 5 : 3;
  for (var j = 0; j < debrisCount; j++) {
    var ang = rand(0, Math.PI * 2);
    var sp = rand(50, 180) * speedMult;
    particles.push({ x: x + rand(-20, 20), y: y + rand(-20, 20), vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp - rand(50, 120), life: rand(0.6, 1.5), size: rand(3, 7), color: "#444", gravity: 400, type: "debris", rotation: rand(0, Math.PI * 2), rotSpeed: rand(-10, 10) });
  }

  var ringCount = isBoss ? 2 : isBig ? 2 : 1;
  for (var k = 0; k < ringCount; k++) {
    (function(idx) {
      setTimeout(function() {
        shockwaves.push({ x: x, y: y, radius: 10, maxRadius: (isBoss ? 180 : isBig ? 120 : 80) + idx * 25, life: 1.0 - idx * 0.2, color: colors[idx % colors.length], width: 3 - idx });
      }, idx * 80);
    })(k);
  }

  if (isBoss) {
    for (var m = 0; m < 3; m++) {
      (function(idx) {
        setTimeout(function() { spawnFirework(x + rand(-60, 60), y + rand(-60, 60), colors); }, idx * 150);
      })(m);
    }
  }

  state.screenShake = isBoss ? 25 : isBig ? 14 : 8;
  state.chromatic = isBoss ? 10 : isBig ? 6 : 3;
  if (isBoss) state.slowMo = 0.25;
}

function addTrail(x, y, color, size) {
  size = size || 2;
  if (trails.length >= CONFIG.TRAIL_LIMIT) return;
  trails.push({ x: x, y: y, size: size, color: color, life: 0.35, alpha: 0.9 });
}

// ============================================================
// AUDIO SYSTEM
// ============================================================
var audioCtx = null;
function ensureAudio() {
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  } catch(e) {}
}

function beep(freq, dur, gain) {
  freq = freq || 440;
  dur = dur || 0.05;
  gain = gain || 0.05;
  if (!audioCtx) return;
  var t0 = audioCtx.currentTime;
  var o = audioCtx.createOscillator();
  var g = audioCtx.createGain();
  o.type = "square";
  o.frequency.value = freq;
  g.gain.setValueAtTime(gain, t0);
  g.gain.exponentialRampToValueAtTime(0.001, t0 + dur);
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start(t0);
  o.stop(t0 + dur);
}

function explosionSound() {
  if (!audioCtx) return;
  var t0 = audioCtx.currentTime;
  var o1 = audioCtx.createOscillator();
  var g1 = audioCtx.createGain();
  o1.type = "sawtooth";
  o1.frequency.setValueAtTime(150, t0);
  o1.frequency.exponentialRampToValueAtTime(30, t0 + 0.4);
  g1.gain.setValueAtTime(0.2, t0);
  g1.gain.exponentialRampToValueAtTime(0.001, t0 + 0.4);
  o1.connect(g1);
  g1.connect(audioCtx.destination);
  o1.start(t0);
  o1.stop(t0 + 0.4);
}

function bossAlarm() {
  if (!audioCtx) return;
  for (var i = 0; i < 3; i++) {
    (function(idx) {
      setTimeout(function() { beep(200, 0.2, 0.08); setTimeout(function() { beep(150, 0.2, 0.08); }, 200); }, idx * 400);
    })(i);
  }
}

// ============================================================
// SETUP & RESIZE
// ============================================================
function resize() {
  var rect = document.getElementById("gameContainer").getBoundingClientRect();
  if (rect.width <= 0 || rect.height <= 0) return;
  
  bg.width = Math.floor(rect.width);
  bg.height = Math.floor(rect.height);
  canvas.width = bg.width;
  canvas.height = bg.height;
  fxCanvas.width = bg.width;
  fxCanvas.height = bg.height;
  overlayCanvas.width = bg.width;
  overlayCanvas.height = bg.height;

  var portrait = isPortrait();
  formation.margin = Math.floor(canvas.width * (portrait ? 0.1 : 0.07));
  formation.dropStep = portrait ? Math.floor(canvas.height * 0.018) : Math.floor(canvas.height * 0.028);
  formation.speed = portrait ? 38 : 48;

  initStars();
  if (player) resetPlayerPosition();
}
window.addEventListener("resize", resize);
window.addEventListener("orientationchange", function() { setTimeout(resize, 200); });

// ============================================================
// SCREEN MANAGEMENT
// ============================================================
function showScreen(name) {
  var isGame = name === "game";
  startScreen.classList.toggle("active", name === "start");
  highScoreScreen.classList.toggle("active", name === "highscores");
  if (vendorScreen) vendorScreen.classList.toggle("active", name === "vendor");
  controlArea.style.display = isGame ? "flex" : "none";
  
  setTimeout(function() { resize(); }, 50);
  
  if (!isGame) {
    renderHighscoreTable(startHighscoreTable);
    renderHighscoreTable(highScoreList);
    
    // V9: Update start screen stats
    if (name === "start") {
      updateStartScreenStats();
    }
  }
}

// V9: Update start screen with permanent upgrades, best wave, etc.
function forceStartGame() {
  if (gameStarted) return;
  gameStarted = true;
  
  ensureAudio();
  showScreen("game");
  
  setTimeout(function() {
    resize();
    restart();
  }, 200);
}

// ============================================================
// CONTROLS
// ============================================================
window.addEventListener("keydown", function(e) {
  state.keys[e.key] = true;
  if (e.key === " ") { state.keys.space = true; e.preventDefault(); }
  ensureAudio();

  // P key - Pause and open equipment/inventory during gameplay
  if ((e.key === "p" || e.key === "P") && state.running && gameStarted) {
    e.preventDefault();
    pauseForInventory();
    return;
  }

  if (nameEntry.style.display === "block" || nameEntry.style.display === "") {
    if (pendingHighscore) {
      if (e.key === "ArrowUp") cycleChar(1);
      if (e.key === "ArrowDown") cycleChar(-1);
      if (e.key === "ArrowRight" || e.key === "Tab") { nextChar(); e.preventDefault(); }
      if (e.key === "Enter") confirmName();
    }
  }
});

// Pause game and show inventory
var isPausedForInventory = false;
function pauseForInventory() {
  if (isPausedForInventory) {
    // Resume
    resumeFromInventory();
    return;
  }
  
  isPausedForInventory = true;
  state.running = false;
  
  // Create pause overlay with equipment
  var pauseOverlay = document.createElement('div');
  pauseOverlay.id = 'pauseInventoryOverlay';
  pauseOverlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.92);z-index:1500;display:flex;align-items:center;justify-content:center;';
  
  var content = '<div style="background:#0a0a1a;border:2px solid #8B5CF6;border-radius:15px;padding:25px;max-width:700px;width:95%;max-height:90vh;overflow-y:auto;">';
  content += '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;">';
  content += '<h2 style="color:#8B5CF6;font-family:Orbitron,monospace;font-size:20px;">‚è∏Ô∏è PAUSED - INVENTORY</h2>';
  content += '<span style="color:#ffd700;font-size:16px;">' + persistentScrap + ' üí∞</span>';
  content += '</div>';
  
  // Equipment slots
  content += '<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:15px;">';
  var slots = ['weapon', 'shield', 'engine', 'pilot', 'mod1', 'mod2', 'special'];
  var icons = {'weapon':'‚öîÔ∏è', 'shield':'üõ°Ô∏è', 'engine':'üöÄ', 'pilot':'üë®‚ÄçüöÄ', 'mod1':'üîß', 'mod2':'üîß', 'special':'‚≠ê'};
  slots.forEach(function(slot) {
    var item = equipmentSlots[slot];
    var filled = item ? 'border-color:#00ff88;' : '';
    content += '<div style="background:rgba(0,0,0,0.4);border:1px solid rgba(139,92,246,0.4);' + filled + 'border-radius:8px;padding:8px;text-align:center;">';
    content += '<div style="font-size:18px;">' + icons[slot] + '</div>';
    content += '<div style="font-size:9px;color:#888;">' + slot.toUpperCase() + '</div>';
    content += '<div style="font-size:9px;color:' + (item ? getRarityColor(item.rarity) : '#555') + ';white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">' + (item ? item.name : 'Empty') + '</div>';
    content += '</div>';
  });
  content += '<div style="background:rgba(0,255,136,0.1);border:1px solid rgba(0,255,136,0.3);border-radius:8px;padding:8px;text-align:center;">';
  content += '<div style="font-size:9px;color:#888;">BONUSES</div>';
  var stats = calculateEquipmentStats();
  content += '<div style="font-size:10px;color:#00ff88;">DMG +' + Math.round((stats.damage-1)*100) + '%</div>';
  content += '<div style="font-size:10px;color:#00ff88;">SPD +' + Math.round((stats.speed-1)*100) + '%</div>';
  content += '</div>';
  content += '</div>';
  
  // Stash preview
  content += '<div style="font-size:12px;color:#00ff88;margin-bottom:8px;">üì¶ Stash: ' + equipmentStash.length + ' items</div>';
  if (equipmentStash.length > 0) {
    content += '<div style="display:flex;flex-wrap:wrap;gap:6px;max-height:80px;overflow-y:auto;padding:8px;background:rgba(0,0,0,0.3);border-radius:6px;">';
    equipmentStash.slice(0, 10).forEach(function(item) {
      content += '<div style="background:rgba(139,92,246,0.1);border:1px solid ' + getRarityColor(item.rarity) + ';border-radius:4px;padding:4px 8px;font-size:10px;">' + (item.icon || 'üì¶') + '</div>';
    });
    if (equipmentStash.length > 10) content += '<div style="color:#888;font-size:10px;padding:4px;">+' + (equipmentStash.length - 10) + ' more</div>';
    content += '</div>';
  }
  
  content += '<div style="margin-top:20px;text-align:center;">';
  content += '<button onclick="resumeFromInventory();" style="padding:12px 40px;background:linear-gradient(135deg,#00ff88,#00d4ff);border:none;border-radius:8px;color:#000;font-family:Orbitron,monospace;font-weight:700;font-size:14px;cursor:pointer;">‚ñ∂ RESUME (P)</button>';
  content += '</div>';
  content += '<div style="text-align:center;margin-top:10px;font-size:10px;color:#555;">Press P or click to resume</div>';
  content += '</div>';
  
  pauseOverlay.innerHTML = content;
  pauseOverlay.onclick = function(e) { if (e.target === pauseOverlay) resumeFromInventory(); };
  document.body.appendChild(pauseOverlay);
}
window.pauseForInventory = pauseForInventory;

function resumeFromInventory() {
  var overlay = document.getElementById('pauseInventoryOverlay');
  if (overlay) overlay.remove();
  isPausedForInventory = false;
  state.running = true;
  requestAnimationFrame(loop);
}
window.resumeFromInventory = resumeFromInventory;

window.addEventListener("keyup", function(e) {
  state.keys[e.key] = false;
  if (e.key === " ") { state.keys.space = false; e.preventDefault(); }
});

var joystick = document.getElementById("joystickContainer");
var stick = document.getElementById("joystickStick");
var fireBtn = document.getElementById("fireButton");

var joyId = null;
var joyCenter = null;

joystick.addEventListener("touchstart", function(e) {
  ensureAudio();
  if (joyId !== null) return;
  var t = e.changedTouches[0];
  joyId = t.identifier;
  var r = joystick.getBoundingClientRect();
  joyCenter = { x: r.left + r.width / 2, y: r.top + r.height / 2, radius: r.width * 0.4 };
  e.preventDefault();
  e.stopPropagation();
}, { passive: false });

joystick.addEventListener("touchmove", function(e) {
  if (joyId === null || !joyCenter) return;
  for (var i = 0; i < e.changedTouches.length; i++) {
    var t = e.changedTouches[i];
    if (t.identifier !== joyId) continue;
    var dx = t.clientX - joyCenter.x;
    var dy = t.clientY - joyCenter.y;
    var mag = Math.hypot(dx, dy);
    var m = mag > 0 ? Math.min(1, mag / joyCenter.radius) : 0;
    var nx = (mag > 0 ? dx / mag : 0) * m;
    var ny = (mag > 0 ? dy / mag : 0) * m;
    state.touch.dir = nx;
    stick.style.transform = "translate(" + (nx * joyCenter.radius * 0.75) + "px, " + (ny * joyCenter.radius * 0.55) + "px)";
  }
  e.preventDefault();
  e.stopPropagation();
}, { passive: false });

function endJoystick() {
  joyId = null;
  joyCenter = null;
  state.touch.dir = 0;
  stick.style.transform = "translate(0,0)";
}

joystick.addEventListener("touchend", function(e) {
  if (joyId === null) return;
  for (var i = 0; i < e.changedTouches.length; i++) {
    if (e.changedTouches[i].identifier === joyId) { endJoystick(); break; }
  }
  e.preventDefault();
  e.stopPropagation();
}, { passive: false });

joystick.addEventListener("touchcancel", function(e) { endJoystick(); e.preventDefault(); e.stopPropagation(); }, { passive: false });

var fireId = null;
fireBtn.addEventListener("touchstart", function(e) {
  ensureAudio();
  if (fireId !== null) return;
  fireId = e.changedTouches[0].identifier;
  state.touch.firing = true;
  e.preventDefault();
  e.stopPropagation();
}, { passive: false });

fireBtn.addEventListener("touchend", function(e) {
  for (var i = 0; i < e.changedTouches.length; i++) {
    if (e.changedTouches[i].identifier === fireId) { fireId = null; state.touch.firing = false; }
  }
  e.preventDefault();
  e.stopPropagation();
}, { passive: false });

fireBtn.addEventListener("touchcancel", function(e) { fireId = null; state.touch.firing = false; e.preventDefault(); e.stopPropagation(); }, { passive: false });

function setupMenuButton(btn, action) {
  var triggered = false;
  var handler = function(e) {
    e.preventDefault();
    e.stopPropagation();
    if (triggered) return;
    triggered = true;
    setTimeout(function() { triggered = false; }, 500);
    action();
  };
  btn.addEventListener("touchstart", handler, { passive: false });
  btn.addEventListener("click", handler);
  btn.addEventListener("pointerdown", handler);
}

setupMenuButton(btnStart, forceStartGame);
setupMenuButton(btnStartFromHS, forceStartGame);
setupMenuButton(btnOpenHighscores, function() { showScreen("highscores"); });
setupMenuButton(btnBackToStart, function() { showScreen("start"); gameStarted = false; });

// ============================================================
// V9: VENDOR SHOP & SHIP SELECTION SYSTEM
// ============================================================
var selectedShip = 'default';
var selectedSkin = 'default';
var unlockedShips = ['default'];
var unlockedSkins = ['default'];
var persistentScrap = 0;
var totalRuns = 0;
var totalKills = 0;

// Load persistent data
function loadPersistentData() {
  try {
    var data = JSON.parse(localStorage.getItem('GALACTICA_PERSISTENT_V9') || '{}');
    persistentScrap = data.scrap || 0;
    unlockedShips = data.ships || ['default'];
    unlockedSkins = data.skins || ['default'];
    selectedShip = data.selectedShip || 'default';
    selectedSkin = data.selectedSkin || 'default';
    totalRuns = data.totalRuns || 0;
    totalKills = data.totalKills || 0;
  } catch(e) {}
}

function savePersistentData() {
  try {
    localStorage.setItem('GALACTICA_PERSISTENT_V9', JSON.stringify({
      scrap: persistentScrap,
      ships: unlockedShips,
      skins: unlockedSkins,
      selectedShip: selectedShip,
      selectedSkin: selectedSkin,
      totalRuns: totalRuns,
      totalKills: totalKills
    }));
  } catch(e) {}
}

// Ship selection
function selectShip(shipId) {
  if (unlockedShips.indexOf(shipId) === -1) return;
  selectedShip = shipId;
  document.querySelectorAll('.ship-option').forEach(function(el) {
    el.classList.remove('selected');
    el.style.borderColor = 'rgba(255,255,255,0.2)';
  });
  var el = document.querySelector('.ship-option[data-ship="' + shipId + '"]');
  if (el) {
    el.classList.add('selected');
    el.style.borderColor = '#00ff88';
  }
  var nameMap = { default: 'Default Fighter', stealth: 'Stealth Interceptor', heavy: 'Heavy Bomber' };
  document.getElementById('selectedShipName').textContent = nameMap[shipId] || shipId;
  savePersistentData();
}

// Skin selection
function selectSkin(skinId) {
  if (unlockedSkins.indexOf(skinId) === -1) return;
  selectedSkin = skinId;
  document.querySelectorAll('.skin-option').forEach(function(el) {
    el.classList.remove('selected');
    el.style.borderColor = 'rgba(255,255,255,0.2)';
  });
  var el = document.querySelector('.skin-option[data-skin="' + skinId + '"]');
  if (el) {
    el.classList.add('selected');
    el.style.borderColor = '#ffd700';
  }
  var nameMap = { default: 'Default', chrome: 'Chrome', inferno: 'Inferno', void: 'Void Walker' };
  document.getElementById('selectedSkinName').textContent = nameMap[skinId] || skinId;
  savePersistentData();
}

// Initialize ship/skin click handlers
document.querySelectorAll('.ship-option').forEach(function(el) {
  el.addEventListener('click', function() {
    var shipId = this.getAttribute('data-ship');
    if (!this.classList.contains('locked')) {
      selectShip(shipId);
    } else {
      showToast('Ship locked! Reach wave 20 to unlock.', 'warn');
    }
  });
});

document.querySelectorAll('.skin-option').forEach(function(el) {
  el.addEventListener('click', function() {
    var skinId = this.getAttribute('data-skin');
    if (!this.classList.contains('locked')) {
      selectSkin(skinId);
    } else {
      showToast('Buy this skin from the shop!', 'warn');
    }
  });
});

// Vendor screen
var vendorScreen = document.getElementById('vendorScreen');
var btnOpenVendor = document.getElementById('btnOpenVendor');

if (btnOpenVendor) {
  btnOpenVendor.addEventListener('click', function() {
    openVendorScreen();
  });
}

// ============================================================
// V10: EQUIPMENT SYSTEM
// ============================================================
var equipmentScreen = document.getElementById('equipmentScreen');
var btnOpenEquipment = document.getElementById('btnOpenEquipment');
var btnBackFromEquip = document.getElementById('btnBackFromEquip');

// Ship Equipment slots
var equipmentSlots = { weapon: null, shield: null, engine: null, reactor: null, mod1: null, mod2: null, special: null };
// Pilot Equipment slots (SEPARATE inventory)
var pilotSlots = { helmet: null, suit: null, gloves: null, boots: null, implant1: null, implant2: null, trinket: null };
// Shared stash
var equipmentStash = [];
// Active tab
var activeEquipTab = 'ship';

function loadEquipment() {
  try {
    var saved = localStorage.getItem('m4nfroid_equipment_v10');
    if (saved) {
      var data = JSON.parse(saved);
      equipmentSlots = data.slots || equipmentSlots;
      pilotSlots = data.pilotSlots || pilotSlots;
      equipmentStash = data.stash || [];
    }
    // TESTING: Give 1,000,000 scrap if not already rich
    if (persistentScrap < 100000) {
      persistentScrap = 1000000;
      savePersistent();
      console.log('üí∞ TEST MODE: Added 1,000,000 scrap!');
    }
  } catch(e) { console.warn('Could not load equipment:', e); }
}

function saveEquipment() {
  try {
    localStorage.setItem('m4nfroid_equipment_v10', JSON.stringify({ 
      slots: equipmentSlots, 
      pilotSlots: pilotSlots,
      stash: equipmentStash 
    }));
  } catch(e) {}
}

function openEquipmentScreen() {
  startScreen.classList.remove('active');
  equipmentScreen.classList.add('active');
  updateEquipScrapDisplay();
  renderEquipmentUI();
  renderPilotUI();
}

function closeEquipmentScreen() {
  equipmentScreen.classList.remove('active');
  startScreen.classList.add('active');
}

function updateEquipScrapDisplay() {
  var el = document.getElementById('equipScrapDisplay');
  if (el) el.textContent = persistentScrap.toLocaleString() + ' üí∞';
}

// Tab switching
function switchEquipTab(tab) {
  activeEquipTab = tab;
  var shipPanel = document.getElementById('shipEquipPanel');
  var pilotPanel = document.getElementById('pilotEquipPanel');
  var tabShip = document.getElementById('tabShipEquip');
  var tabPilot = document.getElementById('tabPilotEquip');
  
  if (tab === 'ship') {
    shipPanel.style.display = 'block';
    pilotPanel.style.display = 'none';
    tabShip.classList.add('active');
    tabShip.style.background = 'linear-gradient(135deg,rgba(0,255,136,0.2),rgba(0,212,255,0.2))';
    tabShip.style.borderColor = '#00ff88';
    tabShip.style.color = '#00ff88';
    tabPilot.classList.remove('active');
    tabPilot.style.background = 'rgba(236,72,153,0.1)';
    tabPilot.style.borderColor = 'rgba(236,72,153,0.3)';
    tabPilot.style.color = '#888';
  } else {
    shipPanel.style.display = 'none';
    pilotPanel.style.display = 'block';
    tabPilot.classList.add('active');
    tabPilot.style.background = 'linear-gradient(135deg,rgba(236,72,153,0.2),rgba(139,92,246,0.2))';
    tabPilot.style.borderColor = '#EC4899';
    tabPilot.style.color = '#EC4899';
    tabShip.classList.remove('active');
    tabShip.style.background = 'rgba(0,255,136,0.1)';
    tabShip.style.borderColor = 'rgba(0,255,136,0.3)';
    tabShip.style.color = '#888';
  }
}
window.switchEquipTab = switchEquipTab;

if (btnOpenEquipment) {
  btnOpenEquipment.addEventListener('click', openEquipmentScreen);
}
if (btnBackFromEquip) {
  btnBackFromEquip.addEventListener('click', closeEquipmentScreen);
}

function renderEquipmentUI() {
  var slotNames = ['weapon', 'shield', 'engine', 'reactor', 'mod1', 'mod2', 'special'];
  slotNames.forEach(function(slot) {
    var el = document.getElementById('slot' + slot.charAt(0).toUpperCase() + slot.slice(1));
    var slotEl = document.querySelector('[data-slot="' + slot + '"]');
    var item = equipmentSlots[slot];
    if (el) {
      if (item) {
        el.textContent = item.name;
        el.style.color = getRarityColor(item.rarity);
        if (slotEl) slotEl.classList.add('filled');
      } else {
        el.textContent = 'Empty';
        el.style.color = '#555';
        if (slotEl) slotEl.classList.remove('filled');
      }
    }
  });
  
  // Update ship stat bonuses
  var stats = calculateEquipmentStats();
  var dmgEl = document.getElementById('equipStatDmg');
  var fireEl = document.getElementById('equipStatFire');
  var spdEl = document.getElementById('equipStatSpd');
  if (dmgEl) dmgEl.textContent = '+' + Math.round((stats.damage - 1) * 100) + '%';
  if (fireEl) fireEl.textContent = '+' + Math.round((stats.fireRate - 1) * 100) + '%';
  if (spdEl) spdEl.textContent = '+' + Math.round((stats.speed - 1) * 100) + '%';
  
  // Render stash
  renderStash();
}

function renderPilotUI() {
  var slotNames = ['helmet', 'suit', 'gloves', 'boots', 'implant1', 'implant2', 'trinket'];
  slotNames.forEach(function(slot) {
    var el = document.getElementById('slot' + slot.charAt(0).toUpperCase() + slot.slice(1));
    var slotEl = document.querySelector('[data-slot="' + slot + '"]');
    var item = pilotSlots[slot];
    if (el) {
      if (item) {
        el.textContent = item.name;
        el.style.color = getRarityColor(item.rarity);
        if (slotEl) slotEl.classList.add('filled');
      } else {
        el.textContent = 'Empty';
        el.style.color = '#555';
        if (slotEl) slotEl.classList.remove('filled');
      }
    }
  });
  
  // Update pilot stat bonuses
  var pStats = calculatePilotStats();
  var critEl = document.getElementById('pilotStatCrit');
  var luckEl = document.getElementById('pilotStatLuck');
  var scrapEl = document.getElementById('pilotStatScrap');
  if (critEl) critEl.textContent = '+' + Math.round(pStats.critChance * 100) + '%';
  if (luckEl) luckEl.textContent = '+' + Math.round(pStats.luck * 100) + '%';
  if (scrapEl) scrapEl.textContent = '+' + Math.round(pStats.scrapBonus * 100) + '%';
}

function renderStash() {
  var stashGrid = document.getElementById('equipmentStashGrid');
  var stashCount = document.getElementById('stashCount');
  if (stashCount) stashCount.textContent = equipmentStash.length;
  
  if (stashGrid) {
    if (equipmentStash.length === 0) {
      stashGrid.innerHTML = '<div style="grid-column:1/-1;text-align:center;color:#555;padding:25px;font-size:11px;">No items yet. Keep loot from debrief!</div>';
    } else {
      stashGrid.innerHTML = '';
      equipmentStash.forEach(function(item, index) {
        var div = document.createElement('div');
        div.className = 'stash-item rarity-' + item.rarity.toLowerCase();
        div.innerHTML = '<div class="item-icon">' + (item.icon || 'üì¶') + '</div><div class="item-name" style="color:' + getRarityColor(item.rarity) + '">' + item.name + '</div>';
        div.onclick = function() { showStashItemMenu(index); };
        stashGrid.appendChild(div);
      });
    }
  }
}

function calculateEquipmentStats() {
  var stats = { damage: 1, fireRate: 1, speed: 1, maxHp: 1 };
  for (var slot in equipmentSlots) {
    var item = equipmentSlots[slot];
    if (item && item.effects) {
      for (var stat in item.effects) {
        if (stats[stat] !== undefined) {
          stats[stat] *= (1 + item.effects[stat]);
        }
      }
    }
  }
  return stats;
}

// Calculate Pilot equipment stats
function calculatePilotStats() {
  var stats = { critChance: 0, luck: 0, scrapBonus: 0, xpBonus: 0 };
  for (var slot in pilotSlots) {
    var item = pilotSlots[slot];
    if (item && item.effects) {
      for (var stat in item.effects) {
        if (stats[stat] !== undefined) {
          stats[stat] += item.effects[stat];
        }
      }
    }
  }
  return stats;
}

// Ship slot selector
function openSlotSelector(slotName) {
  var currentItem = equipmentSlots[slotName];
  
  var modal = document.createElement('div');
  modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);z-index:2000;display:flex;align-items:center;justify-content:center;';
  
  var content = '<div style="background:#0a0a1a;border:2px solid #00ff88;border-radius:12px;padding:20px;max-width:380px;width:90%;">';
  content += '<h3 style="color:#00ff88;margin-bottom:15px;font-family:Orbitron,monospace;font-size:14px;">üöÄ SHIP: ' + slotName.toUpperCase() + '</h3>';
  
  if (currentItem) {
    content += '<div style="margin-bottom:12px;padding:10px;background:rgba(0,255,136,0.1);border:1px solid #00ff88;border-radius:8px;font-size:11px;">';
    content += '<div style="color:#888;">Equipped: <span style="color:' + getRarityColor(currentItem.rarity) + '">' + currentItem.name + '</span></div>';
    content += '<button onclick="unequipShipItem(\'' + slotName + '\');this.closest(\'div\').parentElement.parentElement.remove();renderEquipmentUI();" style="margin-top:6px;padding:5px 10px;background:rgba(255,60,60,0.2);border:1px solid #ff4444;border-radius:4px;color:#ff4444;cursor:pointer;font-size:10px;">Unequip</button>';
    content += '</div>';
  }
  
  if (equipmentStash.length === 0) {
    content += '<div style="color:#555;text-align:center;padding:20px;font-size:11px;">No items in stash</div>';
  } else {
    content += '<div style="max-height:220px;overflow-y:auto;">';
    equipmentStash.forEach(function(item, idx) {
      content += '<div class="stash-item rarity-' + item.rarity.toLowerCase() + '" style="margin-bottom:6px;padding:8px;cursor:pointer;display:flex;align-items:center;gap:8px;" onclick="equipShipFromStash(' + idx + ',\'' + slotName + '\');this.closest(\'div\').parentElement.parentElement.remove();">';
      content += '<span style="font-size:16px;">' + (item.icon || 'üì¶') + '</span>';
      content += '<span style="font-size:11px;color:' + getRarityColor(item.rarity) + '">' + item.name + '</span>';
      content += '</div>';
    });
    content += '</div>';
  }
  
  content += '<button onclick="this.parentElement.parentElement.remove();" style="margin-top:12px;width:100%;padding:10px;background:rgba(255,255,255,0.1);border:1px solid #555;border-radius:6px;color:#888;cursor:pointer;font-size:11px;">Cancel</button>';
  content += '</div>';
  
  modal.innerHTML = content;
  modal.onclick = function(e) { if (e.target === modal) modal.remove(); };
  document.body.appendChild(modal);
}
window.openSlotSelector = openSlotSelector;

// Pilot slot selector
function openPilotSlotSelector(slotName) {
  var currentItem = pilotSlots[slotName];
  
  var modal = document.createElement('div');
  modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);z-index:2000;display:flex;align-items:center;justify-content:center;';
  
  var content = '<div style="background:#0a0a1a;border:2px solid #EC4899;border-radius:12px;padding:20px;max-width:380px;width:90%;">';
  content += '<h3 style="color:#EC4899;margin-bottom:15px;font-family:Orbitron,monospace;font-size:14px;">üë®‚ÄçüöÄ PILOT: ' + slotName.toUpperCase() + '</h3>';
  
  if (currentItem) {
    content += '<div style="margin-bottom:12px;padding:10px;background:rgba(236,72,153,0.1);border:1px solid #EC4899;border-radius:8px;font-size:11px;">';
    content += '<div style="color:#888;">Equipped: <span style="color:' + getRarityColor(currentItem.rarity) + '">' + currentItem.name + '</span></div>';
    content += '<button onclick="unequipPilotItem(\'' + slotName + '\');this.closest(\'div\').parentElement.parentElement.remove();renderPilotUI();" style="margin-top:6px;padding:5px 10px;background:rgba(255,60,60,0.2);border:1px solid #ff4444;border-radius:4px;color:#ff4444;cursor:pointer;font-size:10px;">Unequip</button>';
    content += '</div>';
  }
  
  if (equipmentStash.length === 0) {
    content += '<div style="color:#555;text-align:center;padding:20px;font-size:11px;">No items in stash</div>';
  } else {
    content += '<div style="max-height:220px;overflow-y:auto;">';
    equipmentStash.forEach(function(item, idx) {
      content += '<div class="stash-item rarity-' + item.rarity.toLowerCase() + '" style="margin-bottom:6px;padding:8px;cursor:pointer;display:flex;align-items:center;gap:8px;" onclick="equipPilotFromStash(' + idx + ',\'' + slotName + '\');this.closest(\'div\').parentElement.parentElement.remove();">';
      content += '<span style="font-size:16px;">' + (item.icon || 'üì¶') + '</span>';
      content += '<span style="font-size:11px;color:' + getRarityColor(item.rarity) + '">' + item.name + '</span>';
      content += '</div>';
    });
    content += '</div>';
  }
  
  content += '<button onclick="this.parentElement.parentElement.remove();" style="margin-top:12px;width:100%;padding:10px;background:rgba(255,255,255,0.1);border:1px solid #555;border-radius:6px;color:#888;cursor:pointer;font-size:11px;">Cancel</button>';
  content += '</div>';
  
  modal.innerHTML = content;
  modal.onclick = function(e) { if (e.target === modal) modal.remove(); };
  document.body.appendChild(modal);
}
window.openPilotSlotSelector = openPilotSlotSelector;

// Ship equip/unequip
function equipShipFromStash(stashIndex, slotName) {
  var item = equipmentStash[stashIndex];
  if (!item) return;
  if (equipmentSlots[slotName]) equipmentStash.push(equipmentSlots[slotName]);
  equipmentStash.splice(stashIndex, 1);
  equipmentSlots[slotName] = item;
  saveEquipment();
  renderEquipmentUI();
  showToast('Equipped ' + item.name + ' to ship!', 'success');
}
window.equipShipFromStash = equipShipFromStash;

function unequipShipItem(slotName) {
  var item = equipmentSlots[slotName];
  if (!item) return;
  equipmentStash.push(item);
  equipmentSlots[slotName] = null;
  saveEquipment();
}
window.unequipShipItem = unequipShipItem;

// Pilot equip/unequip
function equipPilotFromStash(stashIndex, slotName) {
  var item = equipmentStash[stashIndex];
  if (!item) return;
  if (pilotSlots[slotName]) equipmentStash.push(pilotSlots[slotName]);
  equipmentStash.splice(stashIndex, 1);
  pilotSlots[slotName] = item;
  saveEquipment();
  renderPilotUI();
  renderStash();
  showToast('Equipped ' + item.name + ' to pilot!', 'success');
}
window.equipPilotFromStash = equipPilotFromStash;

function unequipPilotItem(slotName) {
  var item = pilotSlots[slotName];
  if (!item) return;
  equipmentStash.push(item);
  pilotSlots[slotName] = null;
  saveEquipment();
  renderStash();
}
window.unequipPilotItem = unequipPilotItem;

function equipFromStash(stashIndex, slotName) {
  var item = equipmentStash[stashIndex];
  if (!item) return;
  if (equipmentSlots[slotName]) equipmentStash.push(equipmentSlots[slotName]);
  equipmentStash.splice(stashIndex, 1);
  equipmentSlots[slotName] = item;
  saveEquipment();
  renderEquipmentUI();
  showToast('Equipped ' + item.name + '!', 'success');
}
window.equipFromStash = equipFromStash;

function unequipItem(slotName) {
  var item = equipmentSlots[slotName];
  if (!item) return;
  equipmentStash.push(item);
  equipmentSlots[slotName] = null;
  saveEquipment();
}
window.unequipItem = unequipItem;

function showStashItemMenu(index) {
  var item = equipmentStash[index];
  if (!item) return;
  
  var modal = document.createElement('div');
  modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.9);z-index:2000;display:flex;align-items:center;justify-content:center;';
  
  var sellPrice = Math.floor((LOOT_PRICES[item.rarity] || 50) * 0.5);
  
  var content = '<div style="background:#0a0a1a;border:2px solid ' + getRarityColor(item.rarity) + ';border-radius:12px;padding:20px;max-width:320px;width:90%;text-align:center;">';
  content += '<div style="font-size:40px;margin-bottom:10px;">' + (item.icon || 'üì¶') + '</div>';
  content += '<div style="font-size:16px;color:' + getRarityColor(item.rarity) + ';font-weight:700;">' + item.name + '</div>';
  content += '<div style="font-size:10px;color:#888;margin-bottom:10px;">' + item.rarity + '</div>';
  if (item.description) content += '<p style="color:#aaa;font-size:11px;margin-bottom:12px;">' + item.description + '</p>';
  
  content += '<div style="display:flex;gap:8px;margin-top:12px;">';
  content += '<button onclick="quickEquip(' + index + ');this.closest(\'div\').parentElement.parentElement.remove();" style="flex:1;padding:10px;background:rgba(139,92,246,0.2);border:1px solid #8B5CF6;border-radius:6px;color:#8B5CF6;cursor:pointer;font-size:11px;">‚öîÔ∏è Equip</button>';
  content += '<button onclick="sellFromStash(' + index + ');this.closest(\'div\').parentElement.parentElement.remove();" style="flex:1;padding:10px;background:rgba(255,215,0,0.2);border:1px solid #ffd700;border-radius:6px;color:#ffd700;cursor:pointer;font-size:11px;">' + sellPrice + ' üí∞</button>';
  content += '</div>';
  content += '<button onclick="this.parentElement.parentElement.remove();" style="margin-top:8px;width:100%;padding:8px;background:transparent;border:1px solid #444;border-radius:6px;color:#666;cursor:pointer;font-size:10px;">Cancel</button>';
  content += '</div>';
  
  modal.innerHTML = content;
  modal.onclick = function(e) { if (e.target === modal) modal.remove(); };
  document.body.appendChild(modal);
}
window.showStashItemMenu = showStashItemMenu;

function quickEquip(stashIndex) {
  var slots = ['weapon', 'shield', 'engine', 'pilot', 'mod1', 'mod2', 'special'];
  for (var i = 0; i < slots.length; i++) {
    if (!equipmentSlots[slots[i]]) {
      equipFromStash(stashIndex, slots[i]);
      return;
    }
  }
  equipFromStash(stashIndex, 'mod1');
}
window.quickEquip = quickEquip;

function sellFromStash(index) {
  var item = equipmentStash[index];
  if (!item) return;
  var price = Math.floor((LOOT_PRICES[item.rarity] || 50) * 0.5);
  equipmentStash.splice(index, 1);
  persistentScrap += price;
  savePersistent();
  saveEquipment();
  renderEquipmentUI();
  updateEquipScrapDisplay();
  showToast('Sold for ' + price + ' üí∞', 'gold');
}
window.sellFromStash = sellFromStash;

function addToStash(item) {
  equipmentStash.push(item);
  saveEquipment();
  showToast('Added to stash: ' + item.name, 'success');
}
window.addToStash = addToStash;

// Load equipment on start
loadEquipment();

// ============================================================
// END EQUIPMENT SYSTEM
// ============================================================

function openVendorScreen() {
  startScreen.classList.remove('active');
  vendorScreen.classList.add('active');
  updateVendorScrapDisplay();
  renderVendorItems();
}

function closeVendorScreen() {
  vendorScreen.classList.remove('active');
  startScreen.classList.add('active');
}
window.closeVendorScreen = closeVendorScreen;

function updateVendorScrapDisplay() {
  var el = document.getElementById('vendorScrapDisplay');
  if (el) el.textContent = persistentScrap + ' üí∞';
}

function showVendorTab(tabName) {
  document.querySelectorAll('.vendor-tab').forEach(function(t) {
    t.classList.remove('active');
    t.style.color = '#aaa';
  });
  document.querySelectorAll('.vendor-tab-content').forEach(function(c) {
    c.style.display = 'none';
  });
  
  var tab = document.querySelector('.vendor-tab[data-tab="' + tabName + '"]');
  var content = document.getElementById('vendor' + tabName.charAt(0).toUpperCase() + tabName.slice(1) + 'Tab');
  
  if (tab) {
    tab.classList.add('active');
    tab.style.color = tabName === 'upgrades' ? '#8B5CF6' : (tabName === 'skins' ? '#ffaa00' : '#00ff88');
  }
  if (content) content.style.display = 'grid';
}
window.showVendorTab = showVendorTab;

function renderVendorItems() {
  var upgradesTab = document.getElementById('vendorUpgradesTab');
  var skinsTab = document.getElementById('vendorSkinsTab');
  
  // Sample vendor items
  var vendorUpgrades = [
    { id: 'perm_damage1', name: 'Damage Boost I', price: 500, rarity: 'RARE', icon: '‚öîÔ∏è', desc: '+10% base damage' },
    { id: 'perm_health1', name: 'Hull Upgrade I', price: 400, rarity: 'RARE', icon: 'üõ°Ô∏è', desc: '+25 max health' },
    { id: 'perm_speed1', name: 'Engine Boost I', price: 350, rarity: 'NORMAL', icon: 'üöÄ', desc: '+5% speed' },
    { id: 'perm_crit1', name: 'Targeting System', price: 800, rarity: 'EPIC', icon: 'üéØ', desc: '+5% crit chance' },
  ];
  
  var vendorSkins = [
    { id: 'skin_chrome', name: 'Chrome', price: 1000, rarity: 'RARE', preview: 'ü™û' },
    { id: 'skin_inferno', name: 'Inferno', price: 2000, rarity: 'EPIC', preview: 'üî•' },
    { id: 'skin_void', name: 'Void Walker', price: 5000, rarity: 'LEGENDARY', preview: 'üåë' },
  ];
  
  // Render upgrades
  upgradesTab.innerHTML = '';
  vendorUpgrades.forEach(function(item) {
    var owned = V9UpgradeManager.hasPermanentUpgrade(item.id);
    var canAfford = persistentScrap >= item.price;
    
    var card = document.createElement('div');
    card.className = 'vendor-item-card';
    card.style.cssText = 'background:rgba(0,0,0,0.4);border:2px solid ' + getRarityColor(item.rarity) + ';border-radius:10px;padding:12px;text-align:center;';
    
    card.innerHTML = 
      '<div style="font-size:28px;margin-bottom:8px;">' + item.icon + '</div>' +
      '<div style="font-size:12px;font-weight:700;color:' + getRarityColor(item.rarity) + '">' + item.name + '</div>' +
      '<div style="font-size:10px;color:#888;margin:5px 0;">' + item.desc + '</div>' +
      '<div style="font-size:9px;color:#666;margin-bottom:8px;">' + item.rarity + '</div>' +
      (owned ? 
        '<div style="color:#00ff88;font-size:11px;">‚úî OWNED</div>' :
        '<button onclick="buyVendorItem(\'' + item.id + '\',' + item.price + ')" style="padding:6px 12px;border:1px solid ' + (canAfford ? '#00ff88' : '#666') + ';background:' + (canAfford ? 'rgba(0,255,136,0.2)' : 'transparent') + ';color:' + (canAfford ? '#00ff88' : '#666') + ';border-radius:6px;font-family:Orbitron;font-size:10px;cursor:' + (canAfford ? 'pointer' : 'not-allowed') + ';">' + item.price + ' üí∞</button>'
      );
    
    upgradesTab.appendChild(card);
  });
  
  // Render skins
  skinsTab.innerHTML = '';
  vendorSkins.forEach(function(skin) {
    var owned = unlockedSkins.indexOf(skin.id.replace('skin_', '')) !== -1;
    var canAfford = persistentScrap >= skin.price;
    
    var card = document.createElement('div');
    card.style.cssText = 'background:rgba(0,0,0,0.4);border:2px solid ' + getRarityColor(skin.rarity) + ';border-radius:10px;padding:12px;text-align:center;';
    
    card.innerHTML = 
      '<div style="font-size:36px;margin-bottom:8px;">' + skin.preview + '</div>' +
      '<div style="font-size:12px;font-weight:700;color:' + getRarityColor(skin.rarity) + '">' + skin.name + '</div>' +
      '<div style="font-size:9px;color:#666;margin:5px 0;">' + skin.rarity + '</div>' +
      (owned ? 
        '<div style="color:#00ff88;font-size:11px;">‚úî OWNED</div>' :
        '<button onclick="buyVendorSkin(\'' + skin.id + '\',' + skin.price + ')" style="padding:6px 12px;border:1px solid ' + (canAfford ? '#ffd700' : '#666') + ';background:' + (canAfford ? 'rgba(255,215,0,0.2)' : 'transparent') + ';color:' + (canAfford ? '#ffd700' : '#666') + ';border-radius:6px;font-family:Orbitron;font-size:10px;cursor:' + (canAfford ? 'pointer' : 'not-allowed') + ';">' + skin.price + ' üí∞</button>'
      );
    
    skinsTab.appendChild(card);
  });
}

function getRarityColor(rarity) {
  var colors = { NORMAL: '#9CA3AF', RARE: '#3B82F6', EPIC: '#8B5CF6', LEGENDARY: '#F59E0B', MYTHIC: '#EC4899' };
  return colors[rarity] || '#9CA3AF';
}

function buyVendorItem(itemId, price) {
  if (persistentScrap < price) {
    showToast('Not enough scrap!', 'error');
    return;
  }
  persistentScrap -= price;
  // Add to permanent upgrades
  V9UpgradeManager.applyUpgrade({ id: itemId, type: 'permanent', effects: {} });
  savePersistentData();
  updateVendorScrapDisplay();
  renderVendorItems();
  showToast('Purchased!', 'success');
  beep(880, 0.1, 0.08);
}
window.buyVendorItem = buyVendorItem;

function buyVendorSkin(skinId, price) {
  if (persistentScrap < price) {
    showToast('Not enough scrap!', 'error');
    return;
  }
  var skinKey = skinId.replace('skin_', '');
  if (unlockedSkins.indexOf(skinKey) !== -1) return;
  
  persistentScrap -= price;
  unlockedSkins.push(skinKey);
  savePersistentData();
  updateVendorScrapDisplay();
  renderVendorItems();
  updateSkinSelectionUI();
  showToast('Skin unlocked!', 'success');
  beep(880, 0.1, 0.08);
}
window.buyVendorSkin = buyVendorSkin;

function updateSkinSelectionUI() {
  document.querySelectorAll('.skin-option').forEach(function(el) {
    var skinId = el.getAttribute('data-skin');
    if (unlockedSkins.indexOf(skinId) !== -1) {
      el.classList.remove('locked');
      el.style.opacity = '1';
      el.querySelector('div').textContent = skinId.substring(0, 3).toUpperCase();
    }
  });
}

function updateStartScreenStats() {
  var highWaveEl = document.getElementById('startHighWave');
  var scrapEl = document.getElementById('startTotalScrapValue');
  var runsEl = document.getElementById('startTotalRuns');
  var killsEl = document.getElementById('startTotalKills');
  var permCountEl = document.getElementById('permanentUpgradeCount');
  
  // Best wave from highscores
  var bestWave = 0;
  try {
    if (highscores && highscores.length > 0) {
      for (var i = 0; i < highscores.length; i++) {
        if (highscores[i].wave > bestWave) bestWave = highscores[i].wave;
      }
    }
  } catch(e) {}
  
  if (highWaveEl) highWaveEl.textContent = bestWave;
  if (scrapEl) scrapEl.textContent = persistentScrap;
  if (runsEl) runsEl.textContent = totalRuns;
  if (killsEl) killsEl.textContent = totalKills;
  
  var permUpgrades = [];
  try { permUpgrades = V9UpgradeManager.getAllUpgrades().permanent || []; } catch(e) {}
  if (permCountEl) permCountEl.textContent = permUpgrades.length + ' Upgrades';
  
  // Render loadout
  var loadoutGrid = document.getElementById('loadoutGrid');
  if (loadoutGrid) {
    if (permUpgrades.length === 0) {
      loadoutGrid.innerHTML = '<div style="text-align:center;color:#666;font-size:10px;padding:15px;grid-column:1/-1;">No permanent upgrades yet</div>';
    } else {
      loadoutGrid.innerHTML = '';
      permUpgrades.slice(0, 6).forEach(function(upg) {
        var badge = document.createElement('div');
        badge.style.cssText = 'background:rgba(139,92,246,0.2);border:1px solid rgba(139,92,246,0.4);border-radius:6px;padding:6px;text-align:center;';
        badge.innerHTML = '<div style="font-size:16px;">' + (upg.icon || '‚≠ê') + '</div><div style="font-size:9px;color:#a78bfa;">' + (upg.name || upg.id) + '</div>';
        loadoutGrid.appendChild(badge);
      });
    }
  }
}

// Initialize on load
loadPersistentData();
updateStartScreenStats();
updateSkinSelectionUI();

restartBtn.addEventListener("click", function() {
  hideOverlay();
  gameStarted = false;
  forceStartGame();
});

exitBtn.addEventListener("click", function() {
  hideOverlay();
  state.running = false;
  gameStarted = false;
  showScreen("start");
});

document.addEventListener("keydown", function(e) {
  if (startScreen.classList.contains("active") || highScoreScreen.classList.contains("active")) {
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      forceStartGame();
    }
  }
});

// ============================================================
// PLAYER
// ============================================================
function resetPlayerPosition() {
  if (!player) return;
  player.x = canvas.width / 2 - player.w / 2;
  player.y = canvas.height - player.h - 22;
  player.vx = 0;
}

function initPlayer() {
  var size = Math.min(canvas.width, canvas.height);
  player = {
    w: Math.max(32, Math.floor(size * 0.055)),
    h: Math.max(24, Math.floor(size * 0.045)),
    x: 0, y: 0,
    baseSpeed: isPortrait() ? 450 : 500,
    speed: (isPortrait() ? 450 : 500) * (1 + getShipUpgLevel("spd") * 0.05),
    fireCooldown: 0,
    engineTimer: 0,
    thrustAnim: 0,
    bankAngle: 0
  };
  resetPlayerPosition();
}

function drawFighterJet(x, y, w, h, bank) {
  bank = bank || 0;
  ctx.save();
  ctx.translate(x + w / 2, y + h / 2);
  ctx.rotate(bank * 0.15);
  var scale = w / 32;

  // Revenge mode glow
  if (state.revengeTimer > 0) {
    ctx.shadowColor = "#ff0000";
    ctx.shadowBlur = 25 + Math.sin(gameTime * 15) * 8;
  }

  var gradient = ctx.createRadialGradient(0, h / 2 + 5, 0, 0, h / 2 + 5, 20 * scale);
  gradient.addColorStop(0, "rgba(0, 255, 200, 0.8)");
  gradient.addColorStop(0.3, "rgba(0, 200, 255, 0.4)");
  gradient.addColorStop(1, "rgba(0, 100, 255, 0)");
  ctx.fillStyle = gradient;
  ctx.fillRect(-15 * scale, h / 2 - 5, 30 * scale, 25 * scale);

  ctx.fillStyle = "rgba(0, 100, 80, 0.5)";
  ctx.beginPath();
  ctx.moveTo(0, -h / 2 - 2);
  ctx.lineTo(-w / 2 - 2, h / 2 + 2);
  ctx.lineTo(w / 2 + 2, h / 2 + 2);
  ctx.closePath();
  ctx.fill();

  var bodyGrad = ctx.createLinearGradient(-w / 2, 0, w / 2, 0);
  var baseColor = state.revengeTimer > 0 ? "#ff6666" : "#00ff99";
  bodyGrad.addColorStop(0, state.revengeTimer > 0 ? "#aa4444" : "#00aa66");
  bodyGrad.addColorStop(0.3, baseColor);
  bodyGrad.addColorStop(0.5, state.revengeTimer > 0 ? "#ff8888" : "#00ffaa");
  bodyGrad.addColorStop(0.7, baseColor);
  bodyGrad.addColorStop(1, state.revengeTimer > 0 ? "#aa4444" : "#00aa66");
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.moveTo(0, -h / 2);
  ctx.lineTo(-w / 2, h / 2);
  ctx.lineTo(-w / 4, h / 3);
  ctx.lineTo(0, h / 2 - 5);
  ctx.lineTo(w / 4, h / 3);
  ctx.lineTo(w / 2, h / 2);
  ctx.closePath();
  ctx.fill();

  var cockpitGrad = ctx.createLinearGradient(0, -h / 4, 0, h / 6);
  cockpitGrad.addColorStop(0, "#aaffee");
  cockpitGrad.addColorStop(0.5, "#66ddcc");
  cockpitGrad.addColorStop(1, "#44aa99");
  ctx.fillStyle = cockpitGrad;
  ctx.beginPath();
  ctx.ellipse(0, 0, w / 6, h / 4, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = state.revengeTimer > 0 ? "#ff6666" : "#00ffcc";
  ctx.lineWidth = 2 * scale;
  ctx.beginPath();
  ctx.moveTo(-w / 3, h / 4);
  ctx.lineTo(-w / 2, h / 2);
  ctx.moveTo(w / 3, h / 4);
  ctx.lineTo(w / 2, h / 2);
  ctx.stroke();

  var flameHeight = (8 + Math.sin(player.thrustAnim * 20) * 4) * scale;
  var flameGrad = ctx.createLinearGradient(0, h / 2, 0, h / 2 + flameHeight);
  flameGrad.addColorStop(0, "#00ffff");
  flameGrad.addColorStop(0.3, "#00ff88");
  flameGrad.addColorStop(0.6, "#ffaa00");
  flameGrad.addColorStop(1, "rgba(255, 50, 0, 0)");
  ctx.fillStyle = flameGrad;
  ctx.beginPath();
  ctx.moveTo(-w / 6, h / 2 - 3);
  ctx.lineTo(0, h / 2 + flameHeight);
  ctx.lineTo(w / 6, h / 2 - 3);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

// ============================================================
// ALIEN SPRITES
// ============================================================
function drawAlienSprite(x, y, w, h, type, hp, maxHp, time, bossPhase) {
  // Sprite-first rendering (safe fallback to vector render)
  var __sprKey = null;
  if (type === "boss") {
    __sprKey = chooseBossSpriteKey(bossPhase);
  } else {
    __sprKey = chooseEnemySpriteKey(type);
  }
  if (__sprKey) {
    var __im = getSprite(__sprKey);
    if (__im) {
      ctx.save();
      try {
        ctx.shadowColor = "rgba(0,0,0,0.35)";
        ctx.shadowBlur = 8;
        ctx.drawImage(__im, x, y, w, h);
      } finally {
        ctx.restore();
      }
      return;
    }
  }


  ctx.save();
  ctx.translate(x + w / 2, y + h / 2);

  var hpRatio = hp / maxHp;
  var pulse = Math.sin(time * 5) * 0.1;
  var scale = 1 + pulse * 0.05;
  ctx.scale(scale, scale);

  if (hpRatio < 0.5) {
    ctx.shadowColor = "#ff3300";
    ctx.shadowBlur = 10 + (1 - hpRatio) * 15;
  }

  var grad = ctx.createRadialGradient(0, 0, 0, 0, 0, w / 2);
  var colors = {
    normal: ["#44ff44", "#22aa22", "#115511"],
    tough: ["#ffcc00", "#ff8800", "#cc4400"],
    tank: ["#ff4444", "#aa0000", "#550000"],
    diver: ["#9900ff", "#6600aa", "#330066"],
    shield: ["#00d4ff", "#0088aa", "#003344"],
    sniper: ["#66aaff", "#3355aa", "#111d44"],
    bomber: ["#ff7b2e", "#cc3a00", "#551a00"],
    splitter: ["#88ff66", "#44aa22", "#114411"],
    drone: ["#bbbbbb", "#666666", "#222222"],
    boss: ["#ff3333", "#aa0000", "#550000"]
  };
  var c = colors[type] || colors.normal;
  grad.addColorStop(0, c[0]);
  grad.addColorStop(0.6, c[1]);
  grad.addColorStop(1, c[2]);

  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.ellipse(0, 0, w / 2.2, h / 2.2, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "#ff0000";
  ctx.beginPath();
  ctx.arc(-w / 5, -h / 6, w / 8, 0, Math.PI * 2);
  ctx.arc(w / 5, -h / 6, w / 8, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

// ============================================================
// WAVES & ENEMIES
// ============================================================

// ============================================================
// PHASE 2: ENEMY BEHAVIOR HELPERS
// ============================================================
function spawnDrones(x, y, count) {
  count = count || 2;
  for (var i = 0; i < count; i++) {
    var w = 22, h = 22;
    var hpMul = enemyHpMultiplier();
    var baseHp = 45 + state.wave * 3;
    var hp = Math.round(baseHp * hpMul * 0.90 * enemyEarlyToughness() * CONFIG.ENEMY_HP_GLOBAL_MULTIPLIER);
    enemies.push({
      type: "drone",
      x: x - w / 2 + rand(-18, 18),
      y: y - h / 2 + rand(-10, 10),
      w: w, h: h,
      hp: hp, maxHp: hp,
      alive: true,
      inFormation: false,
      vx: rand(-90, 90),
      vy: rand(120, 170),
      zigzag: true,
      zigzagPhase: rand(0, Math.PI * 2),
      hasShield: false,
      shieldHp: 0,
      shootCooldown: 999
    });
  }
}

function onEnemyKilled(e, kx, ky) {
  // Splitter: spawns drones on death (free-fly, does not affect formation bounds)
  if (e && e.splitOnDeath && e.splitOnDeath > 0) {
    spawnDrones(kx, ky, e.splitOnDeath);
  }
  
  // ============================================================
  // V9 LOOT SYSTEM INTEGRATION (FIXED)
  // ============================================================
  
  // Add scrap on kill
  var scrapAmount = e.type === "boss" ? CONFIG.SCRAP_PER_BOSS : CONFIG.SCRAP_PER_ENEMY;
  addScrap(scrapAmount);
  
  // V9 LOOT SYSTEM: Lifesteal on kill (only if upgrade is APPLIED, not collected)
  var lifesteal = V9UpgradeManager.getStat('lifesteal') || 0;
  if (lifesteal > 0 && state.lives < 5) {
    if (Math.random() < lifesteal * 2) {
      state.lives = Math.min(5, state.lives + 1);
      showToast("LIFESTEAL +1 ‚ù§Ô∏è", "pink");
      spawnSparkles(player.x + player.w / 2, player.y, "#ff69b4", 12);
      beep(523, 0.1, 0.08);
    }
  }
  
  // Check for loot drop from enemy
  var sector = Math.floor((state.wave - 1) / 20) + 1;
  var lootItem = LootSystem.generateEnemyDrop(state.wave, e.type);
  
  if (lootItem) {
    // FIXED: Collect loot to inventory instead of auto-applying
    // Only INSTANT consumables (scrap bonus, XP bonus) apply immediately
    if (lootItem.type === 'instant') {
      // Apply instant consumables immediately
      V9UpgradeManager.applyUpgrade(lootItem);
      showToast(lootItem.name + ' USED!', 'rarity-' + lootItem.rarity.toLowerCase());
    } else {
      // Collect to inventory - will be shown in debrief
      collectLootToInventory(lootItem);
      showLootCollectedToast(lootItem);
    }
  }
  
  // Check for special capsule drops (these still collect to inventory)
  if (e.type !== "boss") {
    // Golden Capsule check
    if (LootSystem.shouldSpawnGoldenCapsule(state.wave, sector)) {
      var goldenLoot = LootSystem.generateGoldenCapsuleLoot();
      if (goldenLoot) {
        collectLootToInventory(goldenLoot);
        showCapsuleNotification('golden', goldenLoot, function() {
          // Just show notification, don't apply yet
        });
      }
    }
    
    // Mythic Capsule check (super rare!)
    if (LootSystem.shouldSpawnMythicCapsule(state.wave)) {
      var mythicLoot = LootSystem.generateMythicCapsuleLoot();
      if (mythicLoot) {
        collectLootToInventory(mythicLoot);
        showCapsuleNotification('mythic', mythicLoot, function() {
          // Just show notification, don't apply yet
        });
      }
    }
  }
}

function enemyRowBaseHp(frontRowIndex) {
  return 70 + 35 * frontRowIndex;
}

// Extra endurance in early game to make upgrades feel meaningful; tapers off by wave 60
function enemyEarlyToughness() {
  var w = state.wave;
  if (w <= 30) return 1.18;
  if (w >= 60) return 1.0;
  return 1.18 - (w - 30) * (0.18 / 30);
}

function createWaveEnemies() {
  var portrait = isPortrait();
  var cols = clamp(6 + Math.floor((state.wave - 1) / 2), 6, portrait ? 9 : 11);
  var rows = clamp(4 + Math.floor((state.wave - 1) / 3), 4, 6);
  var maxGridW = canvas.width * (portrait ? 0.7 : 0.8);
  var gridW = Math.min(maxGridW, 700);
  var spacing = gridW / cols;
  var size = Math.floor(spacing * 0.68);
  var startX = Math.floor((canvas.width - gridW) / 2);
  var startY = Math.floor(80);

  var hpMul = enemyHpMultiplier();
  var features = getDifficultyFeatures();

  enemies = [];
  for (var r = 0; r < rows; r++) {
    for (var c = 0; c < cols; c++) {
      var frontIndex = rows - 1 - r;
      var baseHp = enemyRowBaseHp(frontIndex);
      // Row-based endurance: front row baseline, each row behind +20%
      var rowMul = Math.pow(1.20, frontIndex);
      var hp = Math.max(1, Math.round(baseHp * hpMul * rowMul * enemyEarlyToughness() * CONFIG.ENEMY_HP_GLOBAL_MULTIPLIER));
      var enemyType = "normal";
      var typeRoll = Math.random();

      // Phase 2: richer enemy mix (still formation-safe)
      // Bias tougher/special units towards the back rows (higher frontIndex)
      var backBias = clamp(frontIndex / Math.max(1, rows - 1), 0, 1);

      if (state.wave >= 9 && typeRoll < (0.05 + 0.04 * backBias)) enemyType = "splitter";
      else if (state.wave >= 8 && typeRoll < (0.09 + 0.05 * backBias) && features.shields) enemyType = "shield";
      else if (state.wave >= 7 && typeRoll < (0.10 + 0.05 * backBias)) enemyType = "sniper";
      else if (state.wave >= 12 && typeRoll < (0.06 + 0.03 * backBias)) enemyType = "bomber";
      else if (state.wave >= 5 && typeRoll < 0.08 && features.divers) enemyType = "diver";
      else if (state.wave >= 10 && typeRoll < 0.12) enemyType = "tank";
      else if (state.wave >= 4 && typeRoll < 0.22) enemyType = "tough";
var hpBonus = enemyType === "tank" ? 2.0 : enemyType === "tough" ? 1.5 : enemyType === "shield" ? 1.3 : enemyType === "bomber" ? 1.2 : enemyType === "sniper" ? 1.0 : enemyType === "splitter" ? 1.05 : enemyType === "diver" ? 0.8 : 1.0;

      enemies.push({
        type: enemyType, row: r, col: c,
        x: startX + c * spacing, y: startY + r * spacing,
        w: size, h: size,
        hp: Math.round(hp * hpBonus), maxHp: Math.round(hp * hpBonus),
        alive: true,
        color: "hsl(" + ((r * 35 + state.wave * 12) % 360) + ", 100%, 55%)",
        shootCooldown: rand(1.5, 3.5),
        zigzag: (enemyType === "sniper") ? false : (features.zigzag && Math.random() < 0.3),
        zigzagPhase: rand(0, Math.PI * 2),

        // Phase 2 flags
        inFormation: true,
        freeFly: false,
        sniper: enemyType === "sniper",
        bomber: enemyType === "bomber",
        splitOnDeath: enemyType === "splitter" ? 2 : 0,

        diving: false, diveTarget: null,

        // Shields: dedicated shield type always spawns shielded with higher shield HP
        hasShield: enemyType === "shield" ? true : (features.shields && Math.random() < 0.1),
        shieldHp: enemyType === "shield" ? Math.round(120 + state.wave * 8) : 50
      });
    }
  }

  var tempo = enemyTempoMultiplier();
  formation.speed = (portrait ? 38 : 48) * (0.9 + 0.1 * clamp(tempo, 1, 2.5));
  formation.dir = 1;
  formation.dropCooldown = 0;

  showWaveAnnouncement("WAVE " + state.wave, false);
  state.perfectWave = true;
}

function createBoss() {
  var bw = Math.floor(canvas.width * (isPortrait() ? 0.32 : 0.26));
  var bh = Math.floor(bw * 0.7);
  var hpMul = enemyHpMultiplier();
  var baseHp = 800 + state.wave * 60;
  var hp = Math.round(baseHp * hpMul * CONFIG.BOSS_HP_MULTIPLIER * CONFIG.ENEMY_HP_GLOBAL_MULTIPLIER);

  enemies = [{
    type: "boss",
    x: Math.floor(canvas.width / 2 - bw / 2), y: 85,
    w: bw, h: bh, hp: hp, maxHp: hp,
    alive: true, color: "#ff3b3b",
    vx: isPortrait() ? 80 : 110, dir: 1,
    phase: 1, attackTimer: 0, specialTimer: 0
  }];

  showWaveAnnouncement("!! BOSS !!", true);
  bossAlarm();
  state.perfectWave = true;
}

function showWaveAnnouncement(text, isBoss) {
  waveAnnounce.textContent = text;
  waveAnnounce.className = isBoss ? "show boss" : "show";
  setTimeout(function() { waveAnnounce.className = ""; }, 1800);
}

function advanceToNextWave(){
  state.wave += 1;
  if (typeof hudWave !== "undefined" && hudWave) hudWave.textContent = "WAVE: " + state.wave;
  
  // V9: Reset wave stats for next wave
  state.waveKills = 0;
  state.waveShotsFired = 0;
  state.waveShotsHit = 0;
  state.waveDamageTaken = 0;
  state.waveStartTime = performance.now();
  state.perfectWave = true;
  
  // V9: Reset wave loot drop counter (max 3 drops per wave)
  LootSystem.resetWaveDrops();

  if (state.wave % 5 === 0) {
    createBoss();
  } else {
    createWaveEnemies();
    beep(520, 0.05, 0.03);
  }
}

function nextWave() {
  if (state.perfectWave && state.wave > 1) {
    awardPerfectWave();
  }

  var completedWave = state.wave;
  
  // V9: Calculate wave accuracy before debrief/advance
  if (state.waveShotsFired > 0 || state.waveShotsHit > 0) {
    var totalShots = state.waveShotsFired + state.waveShotsHit;
    state.waveAccuracy = totalShots > 0 ? state.waveShotsHit / totalShots : 0;
  }
  state.waveTime = (performance.now() - (state.waveStartTime || performance.now())) / 1000;
  
  // V9: Award wave completion scrap
  addScrap(CONFIG.SCRAP_PER_WAVE_BONUS);

  // Mission Debrief every N waves (between waves, safe state)
  if (completedWave % CONFIG.DEBRIEF_WAVE_INTERVAL === 0) {
    beginDebrief(completedWave);
    return;
  }

  advanceToNextWave();
}


// ============================================================
// SHOOTING
// ============================================================
function shoot() {
  if (!state.running) return;
  if (player.fireCooldown > 0) return;

  var baseCooldown = hasPowerup("RAPID") ? 0.10 : 0.16;
  var rofBonus = 1 - (getShipUpgLevel("rof") * 0.04);
  rofBonus = Math.max(0.72, rofBonus);
  baseCooldown *= rofBonus;
  var weaponLevel = 0;
  if (permanentUpgrades.dualshot) weaponLevel = permanentUpgrades.dualshotLevel;
  else if (permanentUpgrades.laser) weaponLevel = permanentUpgrades.laserLevel;
  else if (permanentUpgrades.kaboom) weaponLevel = permanentUpgrades.kaboomLevel;
  
  var fireRateBonus = 1 - (weaponLevel * 0.06);
  fireRateBonus = Math.max(0.75, fireRateBonus);
  
  // V9 LOOT SYSTEM: Apply fire rate bonus from upgrades
  var v9FireRate = V9UpgradeManager.getStat('fireRate');
  if (v9FireRate > 1) fireRateBonus /= v9FireRate; // Higher fire rate = lower cooldown
  
  player.fireCooldown = baseCooldown * fireRateBonus;

  var shots = [0];
  var bulletColor = "#00ffaa";
  var bulletDmg = CONFIG.HERO_DAMAGE * getRevengeMult();
  bulletDmg *= CONFIG.PLAYER_DAMAGE_BASE_MULTIPLIER;
  bulletDmg *= (1 + getShipUpgLevel("dmg") * 0.08);
  var isKaboom = false;
  var isLaser = false;
  
  if (hasPowerup("MULTI")) bulletDmg *= 1.25;
  if (hasPowerup("SPEED")) bulletDmg *= 1.15;
  if (hasPowerup("RAPID")) bulletDmg *= 1.15;
  
  // V9 LOOT SYSTEM: Apply upgrade damage bonuses
  var v9DamageMult = V9UpgradeManager.getStat('damage') / 10; // Base damage is 10
  if (v9DamageMult > 1) bulletDmg *= v9DamageMult;
  
  var hasMulti = hasPowerup("MULTI");
  
  if (permanentUpgrades.kaboom) {
    bulletColor = "#ff6600";
    bulletDmg *= 3 * (1 + permanentUpgrades.kaboomLevel * 0.20);
    isKaboom = true;
    shots = hasMulti ? [-12, 0, 12] : [0];
  } else if (permanentUpgrades.laser) {
    bulletColor = "#ff0066";
    bulletDmg *= 1.2 * (1 + permanentUpgrades.laserLevel * 0.20);
    isLaser = true;
    shots = hasMulti ? [-12, 0, 12] : [0];
  } else if (permanentUpgrades.dualshot) {
    bulletColor = "#ffcc00";
    bulletDmg *= (1 + permanentUpgrades.dualshotLevel * 0.20);
    shots = hasMulti ? [-16, -8, 0, 8, 16] : [-12, 12];
  } else if (hasMulti) {
    shots = [-20, -10, 0, 10, 20];
  } else if (hasPowerup("SPEED")) {
    bulletColor = "#ff00ff";
  } else if (hasPowerup("RAPID")) {
    bulletColor = "#ffaa00";
  }

  bulletDmg = Math.floor(bulletDmg * state.multiplier);

  for (var i = 0; i < shots.length; i++) {
    var offset = shots[i];
    var angle = hasMulti ? offset * 0.02 : 0;
    var isPowered = hasPowerup("SHIELD") || hasPowerup("RAPID") || hasPowerup("SPEED");
    
    var b = {
      x: player.x + player.w / 2 - 4 + offset * 0.5,
      y: player.y - 12,
      w: isKaboom ? 12 : (isPowered ? 10 : 8),
      h: isKaboom ? 20 : (isPowered ? 18 : 16),
      vx: Math.sin(angle) * 100,
      vy: isKaboom ? 600 : (isPowered ? 900 : 800),
      dmg: bulletDmg,
      hit: false,
      glow: true,
      color: bulletColor,
      kaboom: isKaboom,
      laser: isLaser
    };
    playerBullets.push(b);
  }

  beep(isKaboom ? 330 : 780, 0.025, 0.015);
  
  // Fire cruise missile if unlocked and cooldown ready
  if (state.level >= CONFIG.MISSILE_UNLOCK_LEVEL && state.missileTimer <= 0) {
    fireCruiseMissile();
    state.missileTimer = getMissileInterval();
  }
}

// ============================================================
// ENEMY FIRE
// ============================================================
var enemyShotTimer = 0;
var enemyNextShotGap = 1.0;
var bossShotTimer = 0;

function maxEnemyBullets() {
  return Math.min(CONFIG.MAX_ENEMY_BULLETS + Math.floor(state.wave / 5), 18);
}

function enemyShotsPerSecond() {
  return 0.8 * 0.45 * enemyTempoMultiplier();
}

function chooseShooterBottomMost() {
  var byCol = {};
  for (var i = 0; i < enemies.length; i++) {
    var e = enemies[i];
    if (!e.alive || e.type === "boss" || e.inFormation === false || e.type === "drone") continue;
    var prev = byCol[e.col];
    if (!prev || e.y > prev.y) byCol[e.col] = e;
  }
  var list = [];
  for (var col in byCol) list.push(byCol[col]);
  if (!list.length) return null;

  var px = player.x + player.w / 2;
  list.sort(function(a, b) { return Math.abs(a.x + a.w / 2 - px) - Math.abs(b.x + b.w / 2 - px); });
  return Math.random() < 0.6 ? list[0] : list[Math.floor(Math.random() * list.length)];
}

function spawnEnemyBullet(x, y, speed, w, h, color, homing, vx) {
  speed = speed || 280;
  w = w || 6;
  h = h || 16;
  color = color || "#ff9a3b";
  homing = homing || false;
  enemyBullets.push({ x: x - w / 2, y: y, w: w, h: h, vy: speed, vx: (vx || 0), color: color, glow: true, homing: homing, homingStrength: homing ? 80 : 0 });
}

function updateEnemyFire(dt) {
  if (!state.running) return;

  var features = getDifficultyFeatures();
  enemyShotTimer += dt;
  bossShotTimer += dt;

  if (enemyBullets.length < maxEnemyBullets()) {
    if (enemyShotTimer >= enemyNextShotGap) {
      enemyShotTimer = 0;
      var shooter = chooseShooterBottomMost();
      if (shooter) {
        var tempo = enemyTempoMultiplier();
        var bulletSpeed = 230 * tempo;
        var homing = features.homing && Math.random() < 0.1;
        // Special shooters
        var w = 6, h = 14, color = homing ? "#ff00ff" : "#ff9a3b";
        var vx = 0;
        if (shooter.type === "sniper") {
          // aimed shot (slight lead)
          var t = Math.max(0.15, (player.y - shooter.y) / bulletSpeed);
          var dx = (player.x + player.w / 2) - (shooter.x + shooter.w / 2);
          vx = clamp(dx / t, -220, 220);
          bulletSpeed *= 1.15;
          w = 5; h = 18;
          color = "#66aaff";
        } else if (shooter.type === "bomber") {
          bulletSpeed *= 0.85;
          w = 10; h = 20;
          color = "#ff7b2e";
        }

spawnEnemyBullet(shooter.x + shooter.w / 2, shooter.y + shooter.h, bulletSpeed, w, h, color, homing, vx);
      }
      enemyNextShotGap = (1 / Math.max(0.12, enemyShotsPerSecond())) * rand(0.7, 1.4);
    }
  }

  var boss = null;
  for (var bi = 0; bi < enemies.length; bi++) {
    if (enemies[bi].type === "boss" && enemies[bi].alive) { boss = enemies[bi]; break; }
  }
  if (boss) {
    var tempo2 = enemyTempoMultiplier();
    var hpRatio = boss.hp / boss.maxHp;
    var phase = hpRatio > 0.66 ? 1 : hpRatio > 0.33 ? 2 : 3;
    boss.phase = phase;
    var interval = (isPortrait() ? 1.2 : 0.9) / tempo2 / (phase * 0.7);

    boss.attackTimer += dt;
    if (boss.attackTimer >= interval && enemyBullets.length < maxEnemyBullets() + 4) {
      boss.attackTimer = 0;
      var count = phase + 2;
      for (var j = 0; j < count; j++) {
        var xOff = (j - (count - 1) / 2) * 25;
        var hm = phase >= 2 && Math.random() < 0.15;
        spawnEnemyBullet(boss.x + boss.w / 2 + xOff, boss.y + boss.h, 280 * tempo2, 8, 18, hm ? "#ff00ff" : "#ff5500", hm);
      }
      beep(200, 0.05, 0.03);
    }

    boss.x += boss.vx * boss.dir * dt;
    if (boss.x < formation.margin || boss.x + boss.w > canvas.width - formation.margin) {
      boss.dir *= -1;
    }
  }

  for (var k = 0; k < enemyBullets.length; k++) {
    var b = enemyBullets[k];
    if (b.homing) {
      var px = player.x + player.w / 2;
      var dx = px - (b.x + b.w / 2);
      b.vx += Math.sign(dx) * b.homingStrength * dt;
      b.vx = clamp(b.vx, -150, 150);
    }
    b.x += (b.vx || 0) * dt;
    b.y += b.vy * dt;
    if (b.glow) addTrail(b.x + b.w / 2, b.y, b.color, 3);
  }
  enemyBullets = enemyBullets.filter(function(b) { return b.y < canvas.height + 30 && b.y > -30 && b.x > -50 && b.x < canvas.width + 50; });
}

// ============================================================
// ENEMY MOVEMENT
// ============================================================
function updateEnemyMovement(dt) {
  // Phase 2: keep formation movement isolated; free-fly units update independently
  var normals = enemies.filter(function(e) { return e.alive && e.type !== "boss" && e.inFormation !== false; });
  var freeFlyList = enemies.filter(function(e) { return e.alive && e.type !== "boss" && e.inFormation === false; });
  if (!normals.length && !freeFlyList.length) return;

  // Update free-fly enemies (drones etc.)
  for (var fi = 0; fi < freeFlyList.length; fi++) {
    var fe = freeFlyList[fi];
    fe.x += (fe.vx || 0) * dt;
    fe.y += (fe.vy || 0) * dt;
    if (fe.zigzag) {
      fe.zigzagPhase += dt * 4.5;
      fe.x += Math.sin(fe.zigzagPhase) * 90 * dt;
    }
    // soft bounce
    if (fe.x < 8) { fe.x = 8; fe.vx = Math.abs(fe.vx || 0); }
    if (fe.x + fe.w > canvas.width - 8) { fe.x = canvas.width - 8 - fe.w; fe.vx = -Math.abs(fe.vx || 0); }
    if (fe.y > canvas.height + 80) fe.alive = false;
  }

  if (!normals.length) return;

  var minX = Infinity, maxX = -Infinity;
  for (var i = 0; i < normals.length; i++) {
    var en = normals[i];
    if (!en.diving) {
      minX = Math.min(minX, en.x);
      maxX = Math.max(maxX, en.x + en.w);
    }
  }

  var tempo = enemyTempoMultiplier();
  var speed = formation.speed * tempo * (isPortrait() ? 0.9 : 1.0);
  var dx = formation.dir * speed * dt;

  var wouldHitLeft = minX + dx < formation.margin;
  var wouldHitRight = maxX + dx > canvas.width - formation.margin;

  formation.dropCooldown = Math.max(0, formation.dropCooldown - dt);

  if ((wouldHitLeft || wouldHitRight) && formation.dropCooldown <= 0) {
    formation.dir *= -1;
    formation.dropCooldown = isPortrait() ? 0.45 : 0.32;
    var drop = formation.dropStep * (isPortrait() ? 0.8 : 1.0);
    for (var j = 0; j < normals.length; j++) {
      if (!normals[j].diving) normals[j].y += drop;
    }
  } else {
    for (var k = 0; k < normals.length; k++) {
      var enn = normals[k];
      if (enn.diving) continue;
      enn.x += dx;
      if (enn.zigzag) {
        enn.zigzagPhase += dt * 4;
        enn.x += Math.sin(enn.zigzagPhase) * 30 * dt;
      }
    }
  }

  var features = getDifficultyFeatures();
  if (features.divers) {
    for (var m = 0; m < normals.length; m++) {
      var ee = normals[m];
      if (ee.type === "diver" && !ee.diving && Math.random() < 0.004) {
        ee.diving = true;
        ee.diveTarget = { x: player.x + player.w / 2, y: player.y };
        ee.originalPos = { x: ee.x, y: ee.y };
      }
      if (ee.diving) {
        var tx = ee.diveTarget.x - ee.w / 2;
        ee.x += (tx - ee.x) * dt * 2;
        ee.y += 400 * dt;
        if (ee.y > canvas.height + 50) {
          ee.diving = false;
          ee.x = ee.originalPos.x;
          ee.y = -50;
        }
      }
    }
  }
}

// ============================================================
// COLLISIONS
// ============================================================
function handlePlayerBullets() {
  var missTriggered = false;

  for (var bi = 0; bi < playerBullets.length; bi++) {
    var b = playerBullets[bi];
    b.y -= b.vy * dtGlobal;
    b.x += (b.vx || 0) * dtGlobal;
    if (b.glow) addTrail(b.x + b.w / 2, b.y, b.color || "#00ff88", 4);
  }

  for (var i = 0; i < playerBullets.length; i++) {
    var bb = playerBullets[i];
    if (bb.hit) continue;
    for (var j = 0; j < enemies.length; j++) {
      var e = enemies[j];
      if (!e.alive) continue;
      if (rectsOverlap(bb, e)) {
        if (!bb.laser) bb.hit = true;

        if (e.hasShield && e.shieldHp > 0) {
          e.shieldHp -= bb.dmg;
          spawnSparkles(bb.x + bb.w / 2, bb.y, "#00d4ff", 8);
          beep(600, 0.03, 0.02);
          if (e.shieldHp <= 0) {
            e.hasShield = false;
            spawnMegaExplosion(e.x + e.w / 2, e.y + e.h / 2, "small");
          }
          break;
        }

        registerHit();

        // V9 LOOT SYSTEM: Enhanced crit chance from upgrades
        var v9CritBonus = V9UpgradeManager.getStat('critChance') || 0;
        var totalCritChance = CONFIG.CRIT_CHANCE + v9CritBonus;
        var isCrit = Math.random() < totalCritChance;
        var damage = isCrit ? Math.round(bb.dmg * CONFIG.CRIT_MULTIPLIER) : bb.dmg;

        e.hp -= damage;
        
        if (bb.kaboom) {
          spawnMegaExplosion(bb.x + bb.w / 2, bb.y + bb.h / 2, "normal");
          state.screenShake = 8;
          beep(220, 0.08, 0.06);
          
          var splashRadius = 60;
          var splashDamage = Math.round(bb.dmg * 0.5);
          var explX = bb.x + bb.w / 2;
          var explY = bb.y + bb.h / 2;
          
          for (var k = 0; k < enemies.length; k++) {
            var other = enemies[k];
            if (!other.alive || other === e) continue;
            var ddx = (other.x + other.w / 2) - explX;
            var ddy = (other.y + other.h / 2) - explY;
            var d = Math.sqrt(ddx * ddx + ddy * ddy);
            
            if (d < splashRadius) {
              other.hp -= splashDamage;
              addFloatText(other.x + other.w / 2, other.y, "-" + splashDamage, "damage");
              spawnParticles(other.x + other.w / 2, other.y + other.h / 2, "#ff6600", 8, 0.8);
              
              if (other.hp <= 0) {
                other.alive = false;
                spawnMegaExplosion(other.x + other.w / 2, other.y + other.h / 2, "normal");
                state.score += 15;
                registerHit();
              }
            }
          }
        }
        
        spawnParticles(bb.x, bb.y, e.color, isCrit ? 25 : bb.kaboom ? 20 : 12, isCrit ? 1.8 : bb.kaboom ? 1.5 : 1);

        if (isCrit) {
          addFloatText(e.x + e.w / 2, e.y, "CRIT! " + Math.floor(damage), "crit");
          state.screenShake = 6;
          state.chromatic = 4;
          beep(1200, 0.05, 0.04);
          spawnSparkles(bb.x + bb.w / 2, bb.y, "#ff0066", 15);
        } else {
          addFloatText(e.x + e.w / 2, e.y, String(damage), "damage");
        }

        if (e.hp <= 0) {
          e.alive = false;
          onEnemyKilled(e, e.x + e.w / 2, e.y + e.h / 2);

          var basePts = e.type === "boss" ? 1000 : e.type === "tank" ? 60 : e.type === "tough" ? 35 : e.type === "diver" ? 45 : e.type === "shield" ? 50 : e.type === "sniper" ? 55 : e.type === "bomber" ? 65 : e.type === "splitter" ? 60 : e.type === "drone" ? 12 : 15;
          var pts = Math.floor(basePts * getStreakFactor() * state.multiplier);
          
          if (state.inRiskZone) {
            pts = Math.floor(pts * CONFIG.RISK_ZONE_BONUS);
          }
          
          state.score += pts;
          
          // XP GAIN ON KILL
          var xpGain = e.type === "boss" ? CONFIG.XP_PER_BOSS_KILL : CONFIG.XP_PER_KILL_BASE;
          gainXP(xpGain);
          
          addFloatText(e.x + e.w / 2, e.y - 12, "+" + Math.floor(pts), "score");

          var explSize = e.type === "boss" ? "boss" : e.type === "tank" ? "big" : "normal";
          spawnMegaExplosion(e.x + e.w / 2, e.y + e.h / 2, explSize);
          explosionSound();

          if (e.type === "boss") {
            if (state.lives < 5) {
              state.lives += 1;
              showToast("+1 LIFE BONUS!", "pink");
            }
            spawnBossDrop(e.x + e.w / 2, e.y + e.h / 2);
            for (var m = 0; m < 4; m++) {
              (function(idx) {
                setTimeout(function() { spawnFirework(rand(100, canvas.width - 100), rand(100, canvas.height / 2)); }, idx * 300);
              })(m);
            }
          } else if (Math.random() < 0.40) {
            spawnPowerupDrop(e.x + e.w / 2, e.y + e.h / 2);
          }

          if (!state.waveTransitioning) {
            var allDead = true;
            for (var x = 0; x < enemies.length; x++) {
              if (enemies[x].alive) { allDead = false; break; }
            }
            if (allDead) {
              state.waveTransitioning = true;
              var delay = e.type === "boss" ? 2500 : 800;
              setTimeout(function() { nextWave(); state.waveTransitioning = false; }, delay);
            }
          }
        } else {
          beep(420, 0.025, 0.015);
        }
        break;
      }
    }
  }

  var still = [];
  for (var si = 0; si < playerBullets.length; si++) {
    var sb = playerBullets[si];
    if (sb.y < -20 || sb.x < -20 || sb.x > canvas.width + 20) {
      if (!sb.hit) missTriggered = true;
      continue;
    }
    if (!sb.hit) still.push(sb);
  }
  playerBullets = still;

  if (missTriggered) registerMiss();
}

function handleEnemyBullets() {
  if (state.invulnT > 0) return;
  if (hasPowerup("SHIELD")) return;

  var pbox = { x: player.x + 4, y: player.y + 4, w: player.w - 8, h: player.h - 8 };
  for (var i = 0; i < enemyBullets.length; i++) {
    var b = enemyBullets[i];
    if (rectsOverlap(b, pbox)) {
      
      // V9 LOOT SYSTEM: Dodge chance
      var dodgeChance = V9UpgradeManager.getStat('dodgeChance') || 0;
      if (dodgeChance > 0 && Math.random() < dodgeChance) {
        showToast("DODGED!", "cyan");
        spawnSparkles(player.x + player.w / 2, player.y + player.h / 2, "#00ffff", 10);
        beep(1000, 0.05, 0.03);
        enemyBullets.splice(i, 1);
        boostMultiplier(0.02);
        continue;
      }
      
      state.perfectWave = false;
      
      if (armor > 0) {
        if (tryDeflectHit()) { enemyBullets.splice(i, 1); updateHUD(); break; }
        armor -= 1;
        showToast("ARMOR -1", "");
        spawnSparkles(player.x + player.w / 2, player.y + player.h / 2, "#888888", 15);
        beep(440, 0.08, 0.06);
        state.invulnT = 0.5;
        activateRevenge();
        updateHUD();
        enemyBullets.splice(i, 1);
        break;
      }
      
      if (tryDeflectHit()) { state.invulnT = 0.4; enemyBullets.splice(i, 1); updateHUD(); break; }
      state.lives -= 1;
      state.waveDamageTaken += 100; // V9: Track damage
      state.invulnT = 1.5;
      spawnMegaExplosion(player.x + player.w / 2, player.y + player.h / 2, "normal");
      explosionSound();
      state.flashAlpha = 0.5;
      
      activateRevenge();

      if (state.lives <= 0) {
        gameOver();
      } else {
        resetPlayerPosition();
      }
      break;
    }
  }
}


function pickupRect(){
  var r = getShipUpgLevel("mag") * 12;
  if (r <= 0) return player;
  return { x: player.x - r, y: player.y - r, w: player.w + r*2, h: player.h + r*2 };
}

function handlePowerups(dt) {
  for (var i = 0; i < powerupDrops.length; i++) {
    var p = powerupDrops[i];
    p.y += p.vy * dt;
    p.pulse += dt * 6;
    p.rotation += dt * 2;

    if (rectsOverlap(p, pickupRect())) {
      addPowerup(p.type);
      p.collected = true;
      spawnSparkles(p.x + p.w / 2, p.y + p.h / 2, p.color, 20);
      spawnFirework(p.x + p.w / 2, p.y + p.h / 2, [p.color]);
    }
  }
  powerupDrops = powerupDrops.filter(function(p) { return !p.collected && p.y < canvas.height; });

  for (var j = 0; j < activePowerups.length; j++) {
    activePowerups[j].timer -= dt;
  }
  var hadPowerups = activePowerups.length;
  activePowerups = activePowerups.filter(function(p) { return p.timer > 0; });
  if (activePowerups.length !== hadPowerups) updatePowerupUI();
}

// ============================================================
// DRAW FUNCTIONS
// ============================================================
var gameTime = 0;

function drawPlayer() {
  var blink = state.invulnT > 0 ? Math.floor(performance.now() / 80) % 2 === 0 : true;
  if (!blink) return;

  player.thrustAnim += dtGlobal;

  var left = state.keys["ArrowLeft"] || state.keys["a"] || state.keys["A"];
  var right = state.keys["ArrowRight"] || state.keys["d"] || state.keys["D"];
  var targetBank = (left ? -1 : 0) + (right ? 1 : 0) + (state.touch.dir || 0);
  player.bankAngle = lerp(player.bankAngle, targetBank, dtGlobal * 8);

  ctx.save();

  if (hasPowerup("SHIELD")) {
    var shieldLeft = getPowerupTimer("SHIELD");
    var warn = shieldLeft > 0 && shieldLeft <= 3;
    var blinkShield = warn ? (Math.floor(performance.now() / 120) % 2 === 0) : true;
    var shieldPulse = Math.sin(gameTime * 8) * 0.3 + 0.7;
    ctx.globalAlpha = (warn ? 0.22 : 0.4) * shieldPulse * (blinkShield ? 1 : 0.25);

    var shieldGrad = ctx.createRadialGradient(player.x + player.w / 2, player.y + player.h / 2, player.w * 0.3, player.x + player.w / 2, player.y + player.h / 2, player.w * 1.0);
    shieldGrad.addColorStop(0, "rgba(0, 212, 255, 0)");
    shieldGrad.addColorStop(0.5, "rgba(0, 212, 255, 0.5)");
    shieldGrad.addColorStop(1, "rgba(0, 212, 255, 0)");

    ctx.fillStyle = shieldGrad;
    ctx.beginPath();
    ctx.arc(player.x + player.w / 2, player.y + player.h / 2, player.w * 0.9, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = "rgba(0, 212, 255, " + (0.6 * shieldPulse) + ")";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  if (!tryDrawPlayerSprite(player.x, player.y, player.w, player.h, player.bankAngle)) {
    drawFighterJet(player.x, player.y, player.w, player.h, player.bankAngle);
  }
  ctx.restore();
}

function drawEnemies() {
  for (var i = 0; i < enemies.length; i++) {
    var e = enemies[i];
    if (!e.alive) continue;

    ctx.save();

    if (e.hasShield && e.shieldHp > 0) {
      ctx.strokeStyle = "rgba(0, 212, 255, " + (0.5 + Math.sin(gameTime * 6) * 0.3) + ")";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(e.x + e.w / 2, e.y + e.h / 2, e.w * 0.7, 0, Math.PI * 2);
      ctx.stroke();
    }

    drawAlienSprite(e.x, e.y, e.w, e.h, e.type, e.hp, e.maxHp, gameTime, e.phase);

    if (e.type !== "normal" || e.maxHp > CONFIG.HERO_DAMAGE) {
      var pct = clamp(e.hp / e.maxHp, 0, 1);
      ctx.globalAlpha = 0.9;

      ctx.fillStyle = "rgba(0,0,0,.7)";
      ctx.fillRect(e.x, e.y - 10, e.w, 6);

      var barGrad = ctx.createLinearGradient(e.x, 0, e.x + e.w * pct, 0);
      if (e.type === "boss") {
        barGrad.addColorStop(0, "#ff0000");
        barGrad.addColorStop(0.5, "#ff6600");
        barGrad.addColorStop(1, "#ffcc00");
      } else {
        barGrad.addColorStop(0, "#00ff88");
        barGrad.addColorStop(1, "#00ffcc");
      }
      ctx.fillStyle = barGrad;
      ctx.fillRect(e.x, e.y - 10, e.w * pct, 6);

      ctx.strokeStyle = e.type === "boss" ? "#ff6666" : "#00ff88";
      ctx.lineWidth = 1;
      ctx.strokeRect(e.x, e.y - 10, e.w, 6);
    }

    ctx.restore();
  }
}

function drawBullets() {
  ctx.save();

  for (var i = 0; i < playerBullets.length; i++) {
    var b = playerBullets[i];
    if (b.laser) {
      ctx.shadowColor = b.color || "#ff0066";
      ctx.shadowBlur = 20;
      
      var beamGrad = ctx.createLinearGradient(b.x + b.w / 2, b.y - 30, b.x + b.w / 2, b.y + b.h + 10);
      beamGrad.addColorStop(0, "rgba(255,0,102,0)");
      beamGrad.addColorStop(0.2, "#ffffff");
      beamGrad.addColorStop(0.5, b.color || "#ff0066");
      beamGrad.addColorStop(0.8, b.color || "#ff0066");
      beamGrad.addColorStop(1, "rgba(255,0,102,0.2)");
      
      ctx.fillStyle = beamGrad;
      ctx.fillRect(b.x + b.w / 2 - 2, b.y - 30, 4, b.h + 40);
      
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(b.x + b.w / 2 - 1, b.y, 2, b.h);
    } else {
      ctx.shadowColor = b.color || "#00ff88";
      ctx.shadowBlur = 12;

      var grad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.h);
      grad.addColorStop(0, "#ffffff");
      grad.addColorStop(0.3, b.color || "#00ffaa");
      grad.addColorStop(1, "rgba(0,255,136,0.3)");

      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(b.x + b.w / 2, b.y + b.h / 2, b.w / 2, b.h / 2, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.shadowBlur = 8;
  for (var j = 0; j < enemyBullets.length; j++) {
    var eb = enemyBullets[j];
    ctx.shadowColor = eb.color;

    var eg = ctx.createRadialGradient(eb.x + eb.w / 2, eb.y + eb.h / 2, 0, eb.x + eb.w / 2, eb.y + eb.h / 2, Math.max(eb.w, eb.h));
    eg.addColorStop(0, "#ffffff");
    eg.addColorStop(0.3, eb.color);
    eg.addColorStop(1, "rgba(255,100,0,0.2)");

    ctx.fillStyle = eg;
    ctx.beginPath();
    ctx.arc(eb.x + eb.w / 2, eb.y + eb.h / 2, Math.max(eb.w, eb.h) / 2, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

function drawPowerups() {
  for (var i = 0; i < powerupDrops.length; i++) {
    var p = powerupDrops[i];
    ctx.save();
    var def = POWERUP_TYPES[p.type];
    var scale = 1 + Math.sin(p.pulse) * 0.15;

    ctx.translate(p.x + p.w / 2, p.y + p.h / 2);
    ctx.rotate(p.rotation);
    ctx.scale(scale, scale);

    ctx.shadowColor = p.color;
    ctx.shadowBlur = 20;

    var grad = ctx.createRadialGradient(0, 0, 0, 0, 0, p.w / 2);
    grad.addColorStop(0, p.color);
    grad.addColorStop(0.5, p.color + "88");
    grad.addColorStop(1, p.color + "00");

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(0, 0, p.w / 2, 0, Math.PI * 2);
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.fillStyle = "#fff";
    ctx.font = "bold 18px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(def.icon, 0, 0);

    ctx.restore();
  }
}

function drawParticles(dt) {
  for (var i = 0; i < particles.length; i++) {
    var p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += p.gravity * dt;
    p.life -= dt;
    if (p.type === "debris" && p.rotation !== undefined) p.rotation += p.rotSpeed * dt;
    if (p.decay) { p.vx *= p.decay; p.vy *= p.decay; }
  }
  particles = particles.filter(function(p) { return p.life > 0; });

  for (var j = 0; j < particles.length; j++) {
    var pp = particles[j];
    ctx.save();
    ctx.globalAlpha = clamp(pp.life, 0, 1);
    if (pp.type === "sparkle") { ctx.shadowColor = pp.color; ctx.shadowBlur = 8; }
    ctx.fillStyle = pp.color;

    if (pp.type === "debris") {
      ctx.translate(pp.x, pp.y);
      ctx.rotate(pp.rotation || 0);
      ctx.fillRect(-pp.size / 2, -pp.size / 2, pp.size, pp.size);
    } else {
      ctx.fillRect(pp.x, pp.y, pp.size, pp.size);
    }
    ctx.restore();
  }
}

function drawFireworks(dt) {
  for (var i = 0; i < fireworks.length; i++) {
    var f = fireworks[i];
    f.x += f.vx * dt;
    f.y += f.vy * dt;
    f.vy += f.gravity * dt;
    f.vx *= 0.99;
    f.vy *= 0.99;
    f.life -= dt;
    f.trail.push({ x: f.x, y: f.y, alpha: 1 });
    if (f.trail.length > f.maxTrail) f.trail.shift();
    for (var t = 0; t < f.trail.length; t++) f.trail[t].alpha -= dt * 3;
  }
  fireworks = fireworks.filter(function(f) { return f.life > 0; });

  for (var j = 0; j < fireworks.length; j++) {
    var ff = fireworks[j];
    for (var k = 0; k < ff.trail.length; k++) {
      var tt = ff.trail[k];
      if (tt.alpha <= 0) continue;
      ctx.globalAlpha = tt.alpha * 0.5;
      ctx.fillStyle = ff.color;
      var trailSize = ff.size * (k / ff.trail.length);
      ctx.fillRect(tt.x - trailSize / 2, tt.y - trailSize / 2, trailSize, trailSize);
    }

    ctx.globalAlpha = clamp(ff.life, 0, 1);
    ctx.shadowColor = ff.color;
    ctx.shadowBlur = 10;
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(ff.x, ff.y, ff.size / 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = ff.color;
    ctx.beginPath();
    ctx.arc(ff.x, ff.y, ff.size / 2 - 1, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
}

function drawTrails(dt) {
  for (var i = 0; i < trails.length; i++) trails[i].life -= dt * 5;
  trails = trails.filter(function(t) { return t.life > 0; });

  for (var j = 0; j < trails.length; j++) {
    var t = trails[j];
    ctx.save();
    ctx.globalAlpha = t.life * t.alpha * 0.6;
    ctx.fillStyle = t.color;
    ctx.fillRect(t.x - t.size / 2, t.y - t.size / 2, t.size, t.size);
    ctx.restore();
  }
}

function drawShockwaves(dt) {
  for (var i = 0; i < shockwaves.length; i++) {
    var s = shockwaves[i];
    s.radius += (s.maxRadius - s.radius) * dt * 6;
    s.life -= dt * 1.5;
  }
  shockwaves = shockwaves.filter(function(s) { return s.life > 0; });

  fxctx.clearRect(0, 0, fxCanvas.width, fxCanvas.height);

  for (var j = 0; j < shockwaves.length; j++) {
    var ss = shockwaves[j];
    fxctx.save();
    fxctx.globalAlpha = ss.life * 0.7;
    fxctx.strokeStyle = ss.color;
    fxctx.lineWidth = ss.width || 3;
    fxctx.beginPath();
    fxctx.arc(ss.x, ss.y, ss.radius, 0, Math.PI * 2);
    fxctx.stroke();

    fxctx.globalAlpha = ss.life * 0.2;
    var grad = fxctx.createRadialGradient(ss.x, ss.y, 0, ss.x, ss.y, ss.radius);
    grad.addColorStop(0, ss.color);
    grad.addColorStop(1, "transparent");
    fxctx.fillStyle = grad;
    fxctx.fill();
    fxctx.restore();
  }
}

function drawFloatTexts(dt) {
  for (var i = 0; i < floatTexts.length; i++) {
    var t = floatTexts[i];
    t.y += t.vy * dt;
    t.x += t.vx * dt;
    t.vy *= 0.95;
    t.vx *= 0.95;
    t.life -= dt;
    if (t.scale > 1) t.scale = lerp(t.scale, 1, dt * 5);
  }
  floatTexts = floatTexts.filter(function(t) { return t.life > 0; });

  for (var j = 0; j < floatTexts.length; j++) {
    var tt = floatTexts[j];
    ctx.save();
    ctx.globalAlpha = clamp(tt.life / 0.3, 0, 1);
    ctx.translate(tt.x, tt.y);
    ctx.rotate(tt.rotation || 0);
    ctx.scale(tt.scale || 1, tt.scale || 1);

    ctx.font = "900 " + tt.size + "px 'Orbitron', monospace";
    ctx.textAlign = "center";

    ctx.strokeStyle = "#000";
    ctx.lineWidth = 3;
    ctx.strokeText(tt.text, 0, 0);

    ctx.shadowColor = tt.color;
    ctx.shadowBlur = 8;
    ctx.fillStyle = tt.color;
    ctx.fillText(tt.text, 0, 0);

    ctx.restore();
  }
}

function drawScreenEffects() {
  if (state.flashAlpha > 0) {
    octx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
    octx.globalAlpha = state.flashAlpha;
    octx.fillStyle = "#fff";
    octx.fillRect(0, 0, overlayCanvas.width, overlayCanvas.height);
    state.flashAlpha -= dtGlobal * 3;
  } else {
    octx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
  }

  if (state.chromatic > 0.5) state.chromatic -= dtGlobal * 15;
}

function draw() {
  ctx.save();

  if (state.screenShake > 0) {
    var intensity = state.screenShake;
    var shakeX = (Math.random() - 0.5) * intensity;
    var shakeY = (Math.random() - 0.5) * intensity;
    ctx.translate(shakeX, shakeY);
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawTrails(dtGlobal);
  drawEnemies();
  drawPlayer();
  drawBullets();
  drawCruiseMissiles();
  drawPowerups();
  drawParticles(dtGlobal);
  drawFireworks(dtGlobal);
  drawFloatTexts(dtGlobal);

  ctx.strokeStyle = "rgba(0,255,136,.18)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, canvas.height - 1);
  ctx.lineTo(canvas.width, canvas.height - 1);
  ctx.stroke();

  ctx.restore();

  drawShockwaves(dtGlobal);
  drawScreenEffects();
}

// ============================================================
// HUD & UI
// ============================================================
function updateHUD() {
  hudScore.textContent = "SCORE: " + Math.floor(state.score).toLocaleString();
  if (typeof hudWave !== "undefined" && hudWave) hudWave.textContent = "WAVE: " + state.wave;

  var pct = streak.bonusPct;
  hudStreak.innerHTML = "STREAK: " + streak.hits + " <small>(+" + pct + "%)</small>";

  if (streak.hits > 0 && streak.hits % 5 === 0) {
    hudStreak.classList.add("pulse");
    setTimeout(function() { hudStreak.classList.remove("pulse"); }, 500);
  }

  livesWrap.innerHTML = "";
  var maxLives = 5;
  var full = Math.max(0, state.lives);
  for (var i = 0; i < maxLives; i++) {
    var span = document.createElement("span");
    span.className = "heart";
    span.textContent = i < full ? "\u2764" : "\u2661";
    span.style.opacity = i < full ? "1" : "0.3";
    span.style.fontSize = "16px";
    span.style.color = i < full ? "#ff3b3b" : "#666";
    livesWrap.appendChild(span);
  }
  
  if (armor > 0) {
    for (var j = 0; j < armor; j++) {
      var armorSpan = document.createElement("span");
      armorSpan.className = "heart";
      armorSpan.textContent = "\u25C6";
      armorSpan.style.fontSize = "14px";
      armorSpan.style.marginLeft = "4px";
      armorSpan.style.color = "#888";
      livesWrap.appendChild(armorSpan);
    }
  }
}

// ============================================================
// GAME FLOW
// ============================================================
function showOverlay(title) {
  overlayTitle.textContent = title;
  finalScore.textContent = Math.floor(state.score).toLocaleString();
  finalWave.textContent = state.wave;
  finalCombo.textContent = state.maxCombo;
  finalLevel.textContent = state.level;
  finalNearMiss.textContent = state.totalNearMisses;
  
  // V9: Display loot stats
  var finalScrapEl = document.getElementById("finalScrap");
  var finalLootEl = document.getElementById("finalLoot");
  if (finalScrapEl) finalScrapEl.textContent = playerScrap.toLocaleString();
  if (finalLootEl) {
    var lootStats = LootSystem.getStats();
    finalLootEl.textContent = lootStats.totalDrops;
  }

  if (isHighscore(state.score)) {
    pendingHighscore = { score: state.score, wave: state.wave };
    nameEntry.style.display = "block";
    setupNameEntry();
  } else {
    nameEntry.style.display = "none";
  }

  renderHighscoreTable();
  overlay.style.display = "flex";
}

function hideOverlay() {
  if (typeof overlay !== "undefined" && overlay) overlay.style.display = "none";
  nameEntry.style.display = "none";
}

function gameOver() {
  state.running = false;
  
  // V9 LOOT SYSTEM: Handle game over
  var lostUpgrades = V9UpgradeManager.gameOver();
  if (lostUpgrades.length > 0) {
    console.log("Lost " + lostUpgrades.length + " upgrades on death");
  }

  for (var i = 0; i < 5; i++) {
    (function(idx) {
      setTimeout(function() {
        spawnFirework(player.x + player.w / 2 + rand(-100, 100), player.y + rand(-100, 50), ["#ff3333", "#ff6600", "#ffcc00"]);
      }, idx * 150);
    })(i);
  }

  setTimeout(function() { showOverlay("GAME OVER"); }, 1000);
}

function restart() {
  hideOverlay();
  state.running = true;
  state.score = 0;
  state.wave = 1;
  state.lives = 3 + getShipUpgLevel("life");
  state.invulnT = 0;
  state.combo = 0;
  state.comboTimer = 0;
  state.maxCombo = 0;
  state.screenShake = 0;
  state.chromatic = 0;
  state.flashAlpha = 0;
  state.slowMo = 0;
  state.waveTransitioning = false;
  state.nearMissCount = 0;
  state.nearMissCooldown = 0;
  state.multiplier = 1.0;
  state.multiplierDecay = 0;
  state.perfectWave = true;
  state.revengeTimer = 0;
  state.inRiskZone = false;
  state.lastMilestone = 0;
  state.totalNearMisses = 0;
  
  // XP RESET
  state.level = 1;
  state.xp = 0;
  state.xpToNextLevel = CONFIG.BASE_XP_PER_LEVEL;
  state.totalXpEarned = 0;
  state.missileTimer = 0;
  state.missilesActive = false;
  cruiseMissiles = [];
  
  // V9 LOOT SYSTEM RESET
  playerScrap = 0;
  updateScrapDisplay();
  V9UpgradeManager.startNewRun();
  LootSystem.resetStats();
  clearSectorLoot();
  vendorStock = [];
  hideDebriefPanels();
  updateActiveUpgradesUI();

  streak.hits = 0;
  streak.bonusPct = 0;
  lastAnnouncedStreak = 0;

  activePowerups = [];
  powerupDrops = [];
  
  permanentUpgrades.dualshot = false;
  permanentUpgrades.laser = false;
  permanentUpgrades.kaboom = false;
  permanentUpgrades.dualshotLevel = 0;
  permanentUpgrades.laserLevel = 0;
  permanentUpgrades.kaboomLevel = 0;
  armor = Math.min(armorCap(), getShipUpgLevel("arm"));
  
  updatePowerupUI();
  updateMultiplierUI();
  updateXPBar();
  updateMissileIndicator();
  revengeBadge.classList.remove("active");
  riskIndicator.classList.remove("active");
  missileIndicator.classList.remove("active");

  initPlayer();
  applyShipUpgradesRuntime();
  playerBullets = [];
  enemyBullets = [];
  particles = [];
  floatTexts = [];
  trails = [];
  shockwaves = [];
  fireworks = [];
  enemyShotTimer = 0;
  bossShotTimer = 0;
  enemyNextShotGap = 1.0;
  gameTime = 0;

  createWaveEnemies();
  updateHUD();
  lastT = performance.now();
  requestAnimationFrame(loop);
}

// ============================================================
// MAIN GAME LOOP
// ============================================================
var lastT = 0;
var dtGlobal = 0;

function update(dt) {
  if (!state.running) return;

  gameTime += dt;

  if (state.slowMo > 0) {
    dt *= 0.3;
    state.slowMo -= dtGlobal;
  }

  var left = state.keys["ArrowLeft"] || state.keys["a"] || state.keys["A"];
  var right = state.keys["ArrowRight"] || state.keys["d"] || state.keys["D"];
  var up = state.keys["ArrowUp"] || state.keys["w"] || state.keys["W"];
  var down = state.keys["ArrowDown"] || state.keys["s"] || state.keys["S"];
  
  var moveDirX = (left ? -1 : 0) + (right ? 1 : 0) + (state.touch.dir || 0);
  var moveDirY = (up ? -1 : 0) + (down ? 1 : 0) + (state.touch.dirY || 0);

  var speedMult = hasPowerup("SPEED") ? 1.3 : 1;
  player.x += moveDirX * player.speed * speedMult * dt;
  player.y += moveDirY * player.speed * speedMult * dt;
  player.x = clamp(player.x, 0, canvas.width - player.w);
  player.y = clamp(player.y, canvas.height * 0.3, canvas.height - player.h - 10);

  var wantFire = state.keys.space || state.touch.firing;
  player.fireCooldown = Math.max(0, player.fireCooldown - dt);
  if (wantFire) shoot();

  state.invulnT = Math.max(0, state.invulnT - dt);
  state.screenShake = Math.max(0, state.screenShake - dt * 25);
  state.nearMissCooldown = Math.max(0, state.nearMissCooldown - dt);

  if (state.combo > 0) {
    state.comboTimer -= dt;
    if (state.comboTimer <= 0) state.combo = 0;
  }

  updateEnemyMovement(dt);
  updateEnemyFire(dt);
  updateCruiseMissiles(dt);

  handlePlayerBullets();
  handleEnemyBullets();
  handlePowerups(dt);
  
  // Addiction mechanics
  checkNearMisses();
  updateRiskZone();
  updateRevenge(dt);
  updateMultiplier(dt);
  checkMilestones();
  
  // Centralized wave completion check (handles missile kills too)
  if (!state.waveTransitioning && enemies.length > 0) {
    var allDead = true;
    for (var wc = 0; wc < enemies.length; wc++) {
      if (enemies[wc].alive) { allDead = false; break; }
    }
    if (allDead) {
      state.waveTransitioning = true;
      setTimeout(function() { nextWave(); state.waveTransitioning = false; }, 800);
    }
  }

  if (state.invulnT <= 0 && !hasPowerup("SHIELD")) {
    var pbox = { x: player.x + 6, y: player.y + 6, w: player.w - 12, h: player.h - 12 };
    for (var i = 0; i < enemies.length; i++) {
      var e = enemies[i];
      if (!e.alive) continue;
      if (e.type === "diver" && e.diving) {
        var ebox = { x: e.x + 8, y: e.y + 8, w: e.w - 16, h: e.h - 16 };
        if (rectsOverlap(ebox, pbox)) {
          e.alive = false;
          state.perfectWave = false;
          
          if (armor > 0) {
            armor -= 1;
            showToast("ARMOR -1", "");
            spawnSparkles(player.x + player.w / 2, player.y + player.h / 2, "#888888", 15);
            spawnMegaExplosion(e.x + e.w / 2, e.y + e.h / 2, "normal");
            beep(440, 0.08, 0.06);
            state.invulnT = 0.5;
            activateRevenge();
            updateHUD();
            break;
          }
          
          if (tryDeflectHit()) { state.invulnT = 0.6; updateHUD(); break; }
          state.lives -= 1;
          state.invulnT = 1.5;
          spawnMegaExplosion(player.x + player.w / 2, player.y + player.h / 2, "normal");
          explosionSound();
          registerMiss();
          activateRevenge();
          if (state.lives <= 0) gameOver();
          else resetPlayerPosition();
          break;
        }
      }
    }
  }

  var dangerY = player.y - 15;
  var nearest = 0;
  for (var j = 0; j < enemies.length; j++) {
    var en = enemies[j];
    if (en.alive && en.type !== "boss" && !en.diving) {
      nearest = Math.max(nearest, en.y + en.h);
    }
  }
  if (nearest > dangerY) {
    state.perfectWave = false;
    if (armor > 0) {
      armor -= 1;
      showToast("ARMOR -1", "");
      spawnSparkles(player.x + player.w / 2, player.y + player.h / 2, "#888888", 20);
      beep(440, 0.1, 0.08);
      state.invulnT = 1.0;
      resetPlayerPosition();
      activateRevenge();
      updateHUD();
    } else {
      if (tryDeflectHit()) {
        state.invulnT = 0.8;
        resetPlayerPosition();
        activateRevenge();
        updateHUD();
      } else {
      state.lives -= 1;
      state.invulnT = 1.5;
      spawnMegaExplosion(player.x + player.w / 2, player.y, "normal");
      explosionSound();
      registerMiss();
      activateRevenge();
      if (state.lives <= 0) gameOver();
      else {
        resetPlayerPosition();
        createWaveEnemies();
      }
      }
    }
  }

  updateHUD();
}

function loop(t) {
  dtGlobal = (t - lastT) / 1000;
  lastT = t;
  dtGlobal = clamp(dtGlobal, 0, 0.035);

  drawStars(dtGlobal);
  update(dtGlobal);
  draw();
  
  // V9: Update active upgrades UI every frame for countdown timers
  if (typeof updateActiveUpgradesUI === 'function') {
    updateActiveUpgradesUI();
  }

  if (state.running) requestAnimationFrame(loop);
}

// ============================================================
// INITIALIZATION
// ============================================================
function init() {
  loadHighscores();

  state.running = false;
  gameStarted = false;

  playerBullets = [];
  enemyBullets = [];
  particles = [];
  floatTexts = [];
  trails = [];
  shockwaves = [];
  fireworks = [];

  activePowerups = [];
  powerupDrops = [];
  cruiseMissiles = [];
  updatePowerupUI();
  updateXPBar();

  setTimeout(function() {
    resize();
    initPlayer();
    createWaveEnemies();
    updateHUD();
    showScreen("start");
  }, 100);
}

init();

} catch (err) {
  console.error("FATAL ERROR:", err);
  var pre = document.createElement("pre");
  pre.style.cssText = "position:absolute;left:10px;right:10px;top:10px;z-index:99999;padding:12px;border:1px solid rgba(0,255,136,.55);background:rgba(0,0,0,.88);color:#00ff88;font:12px/1.35 ui-monospace, monospace;";
  pre.textContent = "ERROR:\n" + (err && err.stack ? err.stack : String(err));
  document.body.appendChild(pre);
}

})();
</script>

</body>
</html>